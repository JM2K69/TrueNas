{
  "openapi": "3.0.0",
  "info": {
    "title": "FreeNAS RESTful API",
    "version": "v2.0"
  },
  "paths": {
    "/core/bulk": {
      "post": {
        "tags": [
          "core"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Will loop on a list of items for the given method, returning a list of\ndicts containing a result and error key.\n\nResult will be the message returned by the method being called,\nor a string of an error, in which case the error key will be the\nexception",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/core_bulk"
              }
            }
          }
        }
      }
    },
    "/core/debug": {
      "post": {
        "tags": [
          "core"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Setup middlewared for remote debugging.\n\nengines:\n  - PTVS: Python Visual Studio\n  - PYDEV: Python Dev (Eclipse/PyCharm)\n  - REMOTE_PDB: Remote vanilla PDB (over TCP sockets)\n\noptions:\n  - secret: password for PTVS\n  - host: required for PYDEV, hostname of local computer (developer workstation)\n  - local_path: required for PYDEV, path for middlewared source in local computer (e.g. /home/user/freenas/src/middlewared/middlewared\n  - threaded: run debugger in a new thread instead of event loop",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/core_debug"
              }
            }
          }
        }
      }
    },
    "/core/download": {
      "post": {
        "tags": [
          "core"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Core helper to call a job marked for download.\n\nReturns the job id and the URL for download.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/core_download"
              }
            }
          }
        }
      }
    },
    "/core/get_events": {
      "get": {
        "tags": [
          "core"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns metadata for every possible event emitted from websocket server."
      }
    },
    "/core/get_jobs": {
      "get": {
        "tags": [
          "core"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Get the long running jobs."
      }
    },
    "/core/get_methods": {
      "post": {
        "tags": [
          "core"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Return methods metadata of every available service.\n\n`service` parameter is optional and filters the result for a single service.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/core_get_methods_0"
              }
            }
          }
        }
      }
    },
    "/core/get_services": {
      "get": {
        "tags": [
          "core"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns a list of all registered services."
      }
    },
    "/core/job_abort": {
      "post": {
        "tags": [
          "core"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/core_job_abort_0"
              }
            }
          }
        }
      }
    },
    "/core/job_update": {
      "post": {
        "tags": [
          "core"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/core_job_update"
              }
            }
          }
        }
      }
    },
    "/core/job_wait": {
      "post": {
        "tags": [
          "core"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/core_job_wait_0"
              }
            }
          }
        }
      }
    },
    "/core/ping": {
      "get": {
        "tags": [
          "core"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Utility method which just returns \"pong\".\nCan be used to keep connection/authtoken alive instead of using\n\"ping\" protocol message."
      }
    },
    "/core/resize_shell": {
      "post": {
        "tags": [
          "core"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Resize terminal session (/websocket/shell) to cols x rows",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/core_resize_shell"
              }
            }
          }
        }
      }
    },
    "/core/sessions": {
      "get": {
        "tags": [
          "core"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Get currently open websocket sessions."
      }
    },
    "/acme/dns/authenticator": {
      "get": {
        "tags": [
          "acme.dns.authenticator"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "acme.dns.authenticator"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a DNS Authenticator\n\nCreate a specific DNS Authenticator containing required authentication details for the said\nprovider to successfully connect with it\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/acme_dns_authenticator_create_0"
              }
            }
          }
        }
      }
    },
    "/acme/dns/authenticator/id/{id}": {
      "delete": {
        "tags": [
          "acme.dns.authenticator"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete DNS Authenticator of `id`\n\n"
      },
      "get": {
        "tags": [
          "acme.dns.authenticator"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "acme.dns.authenticator"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update DNS Authenticator of `id`\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/acme_dns_authenticator_update_1"
              }
            }
          }
        }
      }
    },
    "/acme/dns/authenticator/authenticator_schemas": {
      "get": {
        "tags": [
          "acme.dns.authenticator"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get the schemas for all DNS providers we support for ACME DNS Challenge and the respective attributes\nrequired for connecting to them while validating a DNS Challenge"
      }
    },
    "/acme/dns/authenticator/get_instance": {
      "get": {
        "tags": [
          "acme.dns.authenticator"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/activedirectory": {
      "get": {
        "tags": [
          "activedirectory"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "activedirectory"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update active directory configuration.\n`domainname` full DNS domain name of the Active Directory domain.\n\n`bindname` username used to perform the intial domain join.\n\n`bindpw` password used to perform the initial domain join. User-\nprovided credentials are used to obtain a kerberos ticket, which\nis used to perform the actual domain join.\n\n`ssl` establish SSL/TLS-protected connections to the DCs in the\nActive Directory domain.\n\n`certificate` LDAPs client certificate to be used for certificate-\nbased authentication in the AD domain. If certificate-based\nauthentication is not configured, SASL GSSAPI binds will be performed.\n\n`validate_certificates` specifies whether to perform checks on server\ncertificates in a TLS session. If enabled, TLS_REQCERT demand is set.\nThe server certificate is requested. If no certificate is provided or\nif a bad certificate is provided, the session is immediately terminated.\nIf disabled, TLS_REQCERT allow is set. The server certificate is\nrequested, but all errors are ignored.\n\n`verbose_logging` increase logging during the domain join process.\n\n`use_default_domain` controls whether domain users and groups have\nthe pre-windows 2000 domain name prepended to the user account. When\nenabled, the user appears as \"administrator\" rather than\n\"EXAMPLE\u0007dministrator\"\n\n`allow_trusted_doms` enable support for trusted domains. If this\nparameter is enabled, then separate idmap backends _must_ be configured\nfor each trusted domain, and the idmap cache should be cleared.\n\n`allow_dns_updates` during the domain join process, automatically\ngenerate DNS entries in the AD domain for the NAS. If this is disabled,\nthen a domain administrator must manually add appropriate DNS entries\nfor the NAS. This parameter is recommended for TrueNAS HA servers.\n\n`disable_freenas_cache` disables active caching of AD users and groups.\nWhen disabled, only users cached in winbind's internal cache are\nvisible in GUI dropdowns. Disabling active caching is recommended\nin environments with a large amount of users.\n\n`site` AD site of which the NAS is a member. This parameter is auto-\ndetected during the domain join process. If no AD site is configured\nfor the subnet in which the NAS is configured, then this parameter\nappears as 'Default-First-Site-Name'. Auto-detection is only performed\nduring the initial domain join.\n\n`kerberos_realm` in which the server is located. This parameter is\nautomatically populated during the initial domain join. If the NAS has\nan AD site configured and that site has multiple kerberos servers, then\nthe kerberos realm is automatically updated with a site-specific\nconfiguration to use those servers. Auto-detection is only performed\nduring initial domain join.\n\n`kerberos_principal` kerberos principal to use for AD-related\noperations outside of Samba. After intial domain join, this field is\nupdated with the kerberos principal associated with the AD machine\naccount for the NAS.\n\n`nss_info` controls how Winbind retrieves Name Service Information to\nconstruct a user's home directory and login shell. This parameter\nis only effective if the Active Directory Domain Controller supports\nthe Microsoft Services for Unix (SFU) LDAP schema.\n\n`timeout` timeout value for winbind-related operations. This value may\nneed to be increased in  environments with high latencies for\ncommunications with domain controllers or a large number of domain\ncontrollers. Lowering the value may cause status checks to fail.\n\n`dns_timeout` timeout value for DNS queries during the initial domain\njoin. This value is also set as the NETWORK_TIMEOUT in the ldap config\nfile.\n\n`ldap_sasl_wrapping` defines whether ldap traffic will be signed or\nsigned and encrypted (sealed). LDAP traffic that does not originate\nfrom Samba defaults to using GSSAPI signing unless it is tunnelled\nover LDAPs.\n\n`createcomputer` Active Directory Organizational Unit in which new\ncomputer accounts are created.\n\nThe OU string is read from top to bottom without RDNs. Slashes (\"/\")\nare used as delimiters, like `Computers/Servers/NAS`. The backslash\n(\"\\\") is used to escape characters but not as a separator. Backslashes\nare interpreted at multiple levels and might require doubling or even\nquadrupling to take effect.\n\nWhen this field is blank, new computer accounts are created in the\nActive Directory default OU.\n\nThe Active Directory service is started after a configuration\nupdate if the service was initially disabled, and the updated\nconfiguration sets `enable` to `True`. The Active Directory\nservice is stopped if `enable` is changed to `False`. If the\nconfiguration is updated, but the initial `enable` state is `True`, and\nremains unchanged, then the samba server is only restarted.\n\nDuring the domain join, a kerberos keytab for the newly-created AD\nmachine account is generated. It is used for all future\nLDAP / AD interaction and the user-provided credentials are removed.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/activedirectory_update_0"
              }
            }
          }
        }
      }
    },
    "/activedirectory/change_trust_account_pw": {
      "get": {
        "tags": [
          "activedirectory"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Force an update of the AD machine account password. This can be used to\nrefresh the Kerberos principals in the server's system keytab."
      }
    },
    "/activedirectory/domain_info": {
      "get": {
        "tags": [
          "activedirectory"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns the following information about the currently joined domain:\n\n`LDAP server` IP address of current LDAP server to which TrueNAS is connected.\n\n`LDAP server name` DNS name of LDAP server to which TrueNAS is connected\n\n`Realm` Kerberos realm\n\n`LDAP port`\n\n`Server time` timestamp.\n\n`KDC server` Kerberos KDC to which TrueNAS is connected\n\n`Server time offset` current time offset from DC.\n\n`Last machine account password change`. timestamp"
      }
    },
    "/activedirectory/get_spn_list": {
      "get": {
        "tags": [
          "activedirectory"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Return list of kerberos SPN entries registered for the server's Active\nDirectory computer account. This may not reflect the state of the\nserver's current kerberos keytab."
      }
    },
    "/activedirectory/get_state": {
      "get": {
        "tags": [
          "activedirectory"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Wrapper function for 'directoryservices.get_state'. Returns only the state of the\nActive Directory service."
      }
    },
    "/activedirectory/leave": {
      "post": {
        "tags": [
          "activedirectory"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Leave Active Directory domain. This will remove computer\nobject from AD and clear relevant configuration data from\nthe NAS.\nThis requires credentials for appropriately-privileged user.\nCredentials are used to obtain a kerberos ticket, which is\nused to perform the actual removal from the domain.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/activedirectory_leave_0"
              }
            }
          }
        }
      }
    },
    "/activedirectory/nss_info_choices": {
      "get": {
        "tags": [
          "activedirectory"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns list of available LDAP schema choices."
      }
    },
    "/activedirectory/sasl_wrapping_choices": {
      "get": {
        "tags": [
          "activedirectory"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns list of sasl wrapping choices."
      }
    },
    "/activedirectory/ssl_choices": {
      "get": {
        "tags": [
          "activedirectory"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns list of SSL choices."
      }
    },
    "/activedirectory/started": {
      "get": {
        "tags": [
          "activedirectory"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Issue a no-effect command to our DC. This checks if our secure channel connection to our\ndomain controller is still alive. It has much less impact than wbinfo -t.\nDefault winbind request timeout is 60 seconds, and can be adjusted by the smb4.conf parameter\n'winbind request timeout ='"
      }
    },
    "/afp": {
      "get": {
        "tags": [
          "afp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "afp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update AFP service settings.\n\n`bindip` is a list of IPs to bind AFP to. Leave blank (empty list) to bind to all\navailable IPs.\n\n`map_acls` defines how to map the effective permissions of authenticated users.\nRIGHTS - Unix-style permissions\nMODE - ACLs\nNONE - Do not map\n\n`chmod_request` defines advanced permission control that deals with ACLs.\nPRESERVE - Preserve ZFS ACEs for named users and groups or POSIX ACL group mask\nSIMPLE - Change permission as requested without any extra steps\nIGNORE - Permission change requests are ignored",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/afp_update_0"
              }
            }
          }
        }
      }
    },
    "/afp/bindip_choices": {
      "get": {
        "tags": [
          "afp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "List of valid choices for IP addresses to which to bind the AFP service."
      }
    },
    "/alert/dismiss": {
      "post": {
        "tags": [
          "alert"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Dismiss `id` alert.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/alert_dismiss_0"
              }
            }
          }
        }
      }
    },
    "/alert/list": {
      "get": {
        "tags": [
          "alert"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "List all types of alerts including active/dismissed currently in the system."
      }
    },
    "/alert/list_categories": {
      "get": {
        "tags": [
          "alert"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "List all types of alerts which the system can issue."
      }
    },
    "/alert/list_policies": {
      "get": {
        "tags": [
          "alert"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "List all alert policies which indicate the frequency of the alerts."
      }
    },
    "/alert/restore": {
      "post": {
        "tags": [
          "alert"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Restore `id` alert which had been dismissed.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/alert_restore_0"
              }
            }
          }
        }
      }
    },
    "/alertclasses": {
      "get": {
        "tags": [
          "alertclasses"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "alertclasses"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update default Alert settings.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/alertclasses_update_0"
              }
            }
          }
        }
      }
    },
    "/alertservice": {
      "get": {
        "tags": [
          "alertservice"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "alertservice"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create an Alert Service of specified `type`.\n\nIf `enabled`, it sends alerts to the configured `type` of Alert Service.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/alertservice_create_0"
              }
            }
          }
        }
      }
    },
    "/alertservice/id/{id}": {
      "delete": {
        "tags": [
          "alertservice"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete Alert Service of `id`."
      },
      "get": {
        "tags": [
          "alertservice"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "alertservice"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update Alert Service of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/alertservice_update_1"
              }
            }
          }
        }
      }
    },
    "/alertservice/get_instance": {
      "get": {
        "tags": [
          "alertservice"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/alertservice/list_types": {
      "get": {
        "tags": [
          "alertservice"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "List all types of supported Alert services which can be configured with the system."
      }
    },
    "/alertservice/test": {
      "post": {
        "tags": [
          "alertservice"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Send a test alert using `type` of Alert Service.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/alertservice_test_0"
              }
            }
          }
        }
      }
    },
    "/api_key": {
      "get": {
        "tags": [
          "api_key"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "api_key"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Creates API Key.\n\n`name` is a user-readable name for key.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/api_key_create_0"
              }
            }
          }
        }
      }
    },
    "/api_key/id/{id}": {
      "delete": {
        "tags": [
          "api_key"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete API Key `id`."
      },
      "get": {
        "tags": [
          "api_key"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "api_key"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update API Key `id`.\n\nSpecify `reset: true` to reset this API Key.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/api_key_update_1"
              }
            }
          }
        }
      }
    },
    "/api_key/get_instance": {
      "get": {
        "tags": [
          "api_key"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/auth/check_user": {
      "post": {
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Verify username and password",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/auth_check_user"
              }
            }
          }
        }
      }
    },
    "/auth/generate_token": {
      "post": {
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Generate a token to be used for authentication.\n\n`ttl` stands for Time To Live, in seconds. The token will be invalidated if the connection\nhas been inactive for a time greater than this.\n\n`attrs` is a general purpose object/dictionary to hold information about the token.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/auth_generate_token"
              }
            }
          }
        }
      }
    },
    "/auth/sessions": {
      "get": {
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Returns list of active auth sessions.\n\nExample of return value:\n\n[\n    {\n        \"id\": \"NyhB1J5vjPjIV82yZ6caU12HLA1boDJcZNWuVQM4hQWuiyUWMGZTz2ElDp7Yk87d\",\n        \"origin\": \"192.168.0.3:40392\",\n        \"credentials\": \"TOKEN\",\n        \"internal\": False,\n        \"created_at\": {\"$date\": 1545842426070}\n    }\n]\n\n`credentials` can be `UNIX_SOCKET`, `ROOT_TCP_SOCKET`, `TRUENAS_NODE`, `LOGIN_PASSWORD` or `TOKEN`,\ndepending on what authentication method was used.\n\nIf you want to exclude all internal connections from the list, call this method with following arguments:\n\n[\n    [\n        [\"internal\", \"=\", True]\n    ]\n]"
      }
    },
    "/auth/two_factor_auth": {
      "get": {
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns true if two factor authorization is required for authorizing user's login."
      }
    },
    "/auth/twofactor": {
      "get": {
        "tags": [
          "auth.twofactor"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "auth.twofactor"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "`otp_digits` represents number of allowed digits in the OTP.\n\n`window` extends the validity to `window` many counter ticks before and after the current one.\n\n`interval` is time duration in seconds specifying OTP expiration time from it's creation time.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/auth_twofactor_update_0"
              }
            }
          }
        }
      }
    },
    "/auth/twofactor/provisioning_uri": {
      "get": {
        "tags": [
          "auth.twofactor"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns the provisioning URI for the OTP. This can then be encoded in a QR Code and used to\nprovision an OTP app like Google Authenticator."
      }
    },
    "/auth/twofactor/renew_secret": {
      "get": {
        "tags": [
          "auth.twofactor"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Generates a new secret for Two Factor Authentication. Returns boolean true on success."
      }
    },
    "/auth/twofactor/verify": {
      "post": {
        "tags": [
          "auth.twofactor"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns boolean true if provided `token` is successfully authenticated.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/auth_twofactor_verify_0"
              }
            }
          }
        }
      }
    },
    "/boot/attach": {
      "post": {
        "tags": [
          "boot"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Attach a disk to the boot pool, turning a stripe into a mirror.\n\n`expand` option will determine whether the new disk partition will be\n         the maximum available or the same size as the current disk.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/boot_attach"
              }
            }
          }
        }
      }
    },
    "/boot/detach": {
      "post": {
        "tags": [
          "boot"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Detach given `dev` from boot pool.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/boot_detach_0"
              }
            }
          }
        }
      }
    },
    "/boot/get_disks": {
      "get": {
        "tags": [
          "boot"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns disks of the boot pool."
      }
    },
    "/boot/get_scrub_interval": {
      "get": {
        "tags": [
          "boot"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get Automatic Scrub Interval value in days."
      }
    },
    "/boot/get_state": {
      "get": {
        "tags": [
          "boot"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns the current state of the boot pool, including all vdevs, properties and datasets."
      }
    },
    "/boot/replace": {
      "post": {
        "tags": [
          "boot"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Replace device `label` on boot pool with `dev`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/boot_replace"
              }
            }
          }
        }
      }
    },
    "/boot/scrub": {
      "get": {
        "tags": [
          "boot"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Scrub on boot pool."
      }
    },
    "/boot/set_scrub_interval": {
      "post": {
        "tags": [
          "boot"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Set Automatic Scrub Interval value in days.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/boot_set_scrub_interval_0"
              }
            }
          }
        }
      }
    },
    "/bootenv": {
      "get": {
        "tags": [
          "bootenv"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Query all Boot Environments with `query-filters` and `query-options`."
      },
      "post": {
        "tags": [
          "bootenv"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a new boot environment using `name`.\n\nIf a new boot environment is desired which is a clone of another boot environment, `source` can be passed.\nThen, a new boot environment of `name` is created using boot environment `source` by cloning it.\n\nEnsure that `name` and `source` are valid boot environment names.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/bootenv_create_0"
              }
            }
          }
        }
      }
    },
    "/bootenv/id/{id}": {
      "delete": {
        "tags": [
          "bootenv"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Delete `id` boot environment. This removes the clone from the system."
      },
      "get": {
        "tags": [
          "bootenv"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ],
        "description": "Query all Boot Environments with `query-filters` and `query-options`."
      },
      "put": {
        "tags": [
          "bootenv"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Update `id` boot environment name with a new provided valid `name`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/bootenv_update_1"
              }
            }
          }
        }
      }
    },
    "/bootenv/id/{id}/activate": {
      "post": {
        "tags": [
          "bootenv"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Activates boot environment `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/bootenv_activate"
              }
            }
          }
        }
      }
    },
    "/bootenv/get_instance": {
      "get": {
        "tags": [
          "bootenv"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/bootenv/id/{id}/set_attribute": {
      "post": {
        "tags": [
          "bootenv"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Sets attributes boot environment `id`.\n\nCurrently only `keep` attribute is allowed.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/bootenv_set_attribute_1"
              }
            }
          }
        }
      }
    },
    "/certificate": {
      "get": {
        "tags": [
          "certificate"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "certificate"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a new Certificate\n\nCertificates are classified under following types and the necessary keywords to be passed\nfor `create_type` attribute to create the respective type of certificate\n\n1) Internal Certificate                 -  CERTIFICATE_CREATE_INTERNAL\n\n2) Imported Certificate                 -  CERTIFICATE_CREATE_IMPORTED\n\n3) Certificate Signing Request          -  CERTIFICATE_CREATE_CSR\n\n4) Imported Certificate Signing Request -  CERTIFICATE_CREATE_IMPORTED_CSR\n\n5) ACME Certificate                     -  CERTIFICATE_CREATE_ACME\n\nBy default, created certs use RSA keys. If an Elliptic Curve Key is desired, it can be specified with the\n`key_type` attribute. If the `ec_curve` attribute is not specified for the Elliptic Curve Key, then default to\nusing \"BrainpoolP384R1\" curve.\n\nA type is selected by the Certificate Service based on `create_type`. The rest of the values in `data` are\nvalidated accordingly and finally a certificate is made based on the selected type.\n\n`cert_extensions` can be specified to set X509v3 extensions.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/certificate_create_0"
              }
            }
          }
        }
      }
    },
    "/certificate/id/{id}": {
      "delete": {
        "tags": [
          "certificate"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete certificate of `id`.\n\nIf the certificate is an ACME based certificate, certificate service will try to\nrevoke the certificate by updating it's status with the ACME server, if it fails an exception is raised\nand the certificate is not deleted from the system. However, if `force` is set to True, certificate is deleted\nfrom the system even if some error occurred while revoking the certificate with the ACME Server\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/certificate_delete_1"
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "certificate"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "certificate"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update certificate of `id`\n\nOnly name and revoked attribute can be updated.\n\nWhen `revoked` is enabled, the specified cert `id` is revoked and if it belongs to a CA chain which\nexists on this system, its serial number is added to the CA's certificate revocation list.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/certificate_update_1"
              }
            }
          }
        }
      }
    },
    "/certificate/acme_server_choices": {
      "get": {
        "tags": [
          "certificate"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Dictionary of popular ACME Servers with their directory URI endpoints which we display automatically\nin UI"
      }
    },
    "/certificate/country_choices": {
      "get": {
        "tags": [
          "certificate"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns country choices for creating a certificate/csr."
      }
    },
    "/certificate/ec_curve_choices": {
      "get": {
        "tags": [
          "certificate"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Dictionary of supported EC curves."
      }
    },
    "/certificate/extended_key_usage_choices": {
      "get": {
        "tags": [
          "certificate"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Dictionary of choices for `ExtendedKeyUsage` extension which can be passed over to `usages` attribute."
      }
    },
    "/certificate/get_instance": {
      "get": {
        "tags": [
          "certificate"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/certificate/key_type_choices": {
      "get": {
        "tags": [
          "certificate"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Dictionary of supported key types for certificates."
      }
    },
    "/certificate/profiles": {
      "get": {
        "tags": [
          "certificate"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns a dictionary of predefined options for specific use cases i.e openvpn client/server\nconfigurations which can be used for creating certificates."
      }
    },
    "/certificateauthority": {
      "get": {
        "tags": [
          "certificateauthority"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "certificateauthority"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a new Certificate Authority\n\nCertificate Authorities are classified under following types with the necessary keywords to be passed\nfor `create_type` attribute to create the respective type of certificate authority\n\n1) Internal Certificate Authority       -  CA_CREATE_INTERNAL\n\n2) Imported Certificate Authority       -  CA_CREATE_IMPORTED\n\n3) Intermediate Certificate Authority   -  CA_CREATE_INTERMEDIATE\n\nCreated certificate authorities use RSA keys by default. If an Elliptic Curve Key is desired, then it can be\nspecified with the `key_type` attribute. If the `ec_curve` attribute is not specified for the Elliptic\nCurve Key, default to using \"BrainpoolP384R1\" curve.\n\nA type is selected by the Certificate Authority Service based on `create_type`. The rest of the values\nare validated accordingly and finally a certificate is made based on the selected type.\n\n`cert_extensions` can be specified to set X509v3 extensions.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/certificateauthority_create_0"
              }
            }
          }
        }
      }
    },
    "/certificateauthority/id/{id}": {
      "delete": {
        "tags": [
          "certificateauthority"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete a Certificate Authority of `id`\n\n"
      },
      "get": {
        "tags": [
          "certificateauthority"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "certificateauthority"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update Certificate Authority of `id`\n\nOnly `name` and `revoked` attribute can be updated.\n\nIf `revoked` is enabled, the CA and its complete chain is marked as revoked and added to the CA's\ncertificate revocation list.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/certificateauthority_update_1"
              }
            }
          }
        }
      }
    },
    "/certificateauthority/ca_sign_csr": {
      "post": {
        "tags": [
          "certificateauthority"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Sign CSR by Certificate Authority of `ca_id`\n\nSign CSR's and generate a certificate from it. `ca_id` provides which CA is to be used for signing\na CSR of `csr_cert_id` which exists in the system\n\n`cert_extensions` can be specified if specific extensions are to be set in the newly signed certificate.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/certificateauthority_ca_sign_csr_0"
              }
            }
          }
        }
      }
    },
    "/certificateauthority/get_instance": {
      "get": {
        "tags": [
          "certificateauthority"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/certificateauthority/profiles": {
      "get": {
        "tags": [
          "certificateauthority"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns a dictionary of predefined options for specific use cases i.e OpenVPN certificate authority\nconfigurations which can be used for creating certificate authorities."
      }
    },
    "/cloudsync": {
      "get": {
        "tags": [
          "cloudsync"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Query all Cloud Sync Tasks with `query-filters` and `query-options`."
      },
      "post": {
        "tags": [
          "cloudsync"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Creates a new cloud_sync entry.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/cloudsync_create_0"
              }
            }
          }
        }
      }
    },
    "/cloudsync/id/{id}": {
      "delete": {
        "tags": [
          "cloudsync"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Deletes cloud_sync entry `id`."
      },
      "get": {
        "tags": [
          "cloudsync"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ],
        "description": "Query all Cloud Sync Tasks with `query-filters` and `query-options`."
      },
      "put": {
        "tags": [
          "cloudsync"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Updates the cloud_sync entry `id` with `data`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/cloudsync_update_1"
              }
            }
          }
        }
      }
    },
    "/cloudsync/id/{id}/abort": {
      "post": {
        "tags": [
          "cloudsync"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Aborts cloud sync task.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/cloudsync_abort"
              }
            }
          }
        }
      }
    },
    "/cloudsync/common_task_schema": {
      "get": {
        "tags": [
          "cloudsync"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      }
    },
    "/cloudsync/get_instance": {
      "get": {
        "tags": [
          "cloudsync"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/cloudsync/list_buckets": {
      "post": {
        "tags": [
          "cloudsync"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/cloudsync_list_buckets_0"
              }
            }
          }
        }
      }
    },
    "/cloudsync/list_directory": {
      "post": {
        "tags": [
          "cloudsync"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "List contents of a remote bucket / directory.\n\nIf remote supports buckets, path is constructed by two keys \"bucket\"/\"folder\" in `attributes`.\nIf remote does not support buckets, path is constructed using \"folder\" key only in `attributes`.\n\"folder\" is directory name and \"bucket\" is bucket name for remote.\n\nPath examples:\n\nS3 Service\n`bucketname/directory/name`\n\nDropbox Service\n`directory/name`\n\n\n`credentials` is a valid id of a Cloud Sync Credential which will be used to connect to the provider.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/cloudsync_list_directory_0"
              }
            }
          }
        }
      }
    },
    "/cloudsync/onedrive_list_drives": {
      "post": {
        "tags": [
          "cloudsync"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Lists all available drives and their types for given Microsoft OneDrive credentials.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/cloudsync_onedrive_list_drives_0"
              }
            }
          }
        }
      }
    },
    "/cloudsync/providers": {
      "get": {
        "tags": [
          "cloudsync"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns a list of dictionaries of supported providers for Cloud Sync Tasks.\n\n`credentials_schema` is JSON schema for credentials attributes.\n\n`task_schema` is JSON schema for task attributes.\n\n`buckets` is a boolean value which is set to \"true\" if provider supports buckets.\n\nExample of a single provider:\n\n[\n    {\n        \"name\": \"AMAZON_CLOUD_DRIVE\",\n        \"title\": \"Amazon Cloud Drive\",\n        \"credentials_schema\": [\n            {\n                \"property\": \"client_id\",\n                \"schema\": {\n                    \"title\": \"Amazon Application Client ID\",\n                    \"_required_\": true,\n                    \"type\": \"string\"\n                }\n            },\n            {\n                \"property\": \"client_secret\",\n                \"schema\": {\n                    \"title\": \"Application Key\",\n                    \"_required_\": true,\n                    \"type\": \"string\"\n                }\n            }\n        ],\n        \"credentials_oauth\": null,\n        \"buckets\": false,\n        \"bucket_title\": \"Bucket\",\n        \"task_schema\": []\n    }\n]"
      }
    },
    "/cloudsync/id/{id}/restore": {
      "post": {
        "tags": [
          "cloudsync"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Create the opposite of cloud sync task `id` (PULL if it was PUSH and vice versa).",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/cloudsync_restore_1"
              }
            }
          }
        }
      }
    },
    "/cloudsync/id/{id}/sync": {
      "post": {
        "tags": [
          "cloudsync"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Run the cloud_sync job `id`, syncing the local data to remote.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/cloudsync_sync_1"
              }
            }
          }
        }
      }
    },
    "/cloudsync/sync_onetime": {
      "post": {
        "tags": [
          "cloudsync"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Run cloud sync task without creating it.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/cloudsync_sync_onetime"
              }
            }
          }
        }
      }
    },
    "/cloudsync/credentials": {
      "get": {
        "tags": [
          "cloudsync.credentials"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "cloudsync.credentials"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create Cloud Sync Credentials.\n\n`attributes` is a dictionary of valid values which will be used to authorize with the `provider`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/cloudsync_credentials_create_0"
              }
            }
          }
        }
      }
    },
    "/cloudsync/credentials/id/{id}": {
      "delete": {
        "tags": [
          "cloudsync.credentials"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete Cloud Sync Credentials of `id`."
      },
      "get": {
        "tags": [
          "cloudsync.credentials"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "cloudsync.credentials"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update Cloud Sync Credentials of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/cloudsync_credentials_update_1"
              }
            }
          }
        }
      }
    },
    "/cloudsync/credentials/get_instance": {
      "get": {
        "tags": [
          "cloudsync.credentials"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/cloudsync/credentials/verify": {
      "post": {
        "tags": [
          "cloudsync.credentials"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Verify if `attributes` provided for `provider` are authorized by the `provider`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/cloudsync_credentials_verify_0"
              }
            }
          }
        }
      }
    },
    "/config/reset": {
      "post": {
        "tags": [
          "config"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Reset database to configuration defaults.\n\nIf `reboot` is true this job will reboot the system after its completed with a delay of 10\nseconds.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/config_reset_0"
              }
            }
          }
        }
      }
    },
    "/cronjob": {
      "get": {
        "tags": [
          "cronjob"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "cronjob"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a new cron job.\n\n`stderr` and `stdout` are boolean values which if `true`, represent that we would like to suppress\nstandard error / standard output respectively.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/cronjob_create_0"
              }
            }
          }
        }
      }
    },
    "/cronjob/id/{id}": {
      "delete": {
        "tags": [
          "cronjob"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete cronjob of `id`."
      },
      "get": {
        "tags": [
          "cronjob"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "cronjob"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update cronjob of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/cronjob_update_1"
              }
            }
          }
        }
      }
    },
    "/cronjob/get_instance": {
      "get": {
        "tags": [
          "cronjob"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/cronjob/run": {
      "post": {
        "tags": [
          "cronjob"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Job to run cronjob task of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/cronjob_run_0"
              }
            }
          }
        }
      }
    },
    "/device/get_info": {
      "post": {
        "tags": [
          "device"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get info for SERIAL/DISK device types.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/device_get_info_0"
              }
            }
          }
        }
      }
    },
    "/directoryservices/cache_refresh": {
      "get": {
        "tags": [
          "directoryservices"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      }
    },
    "/directoryservices/get_state": {
      "get": {
        "tags": [
          "directoryservices"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "`DISABLED` Directory Service is disabled.\n\n`FAULTED` Directory Service is enabled, but not HEALTHY. Review logs and generated alert\nmessages to debug the issue causing the service to be in a FAULTED state.\n\n`LEAVING` Directory Service is in process of stopping.\n\n`JOINING` Directory Service is in process of starting.\n\n`HEALTHY` Directory Service is enabled, and last status check has passed."
      }
    },
    "/disk": {
      "get": {
        "tags": [
          "disk"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      }
    },
    "/disk/id/{id}": {
      "get": {
        "tags": [
          "disk"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "disk"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Update disk of `id`.\n\nIf extra options need to be passed to SMART which we don't already support, they can be passed by\n`smartoptions`.\n\n`critical`, `informational` and `difference` are integer values on which alerts for SMART are configured\nif the disk temperature crosses the assigned threshold for each respective attribute.\nIf they are set to null, then SMARTD config values are used as defaults.\n\nEmail of log level LOG_CRIT is issued when disk temperature crosses `critical`.\n\nEmail of log level LOG_INFO is issued when disk temperature crosses `informational`.\n\nIf temperature of a disk changes by `difference` degree Celsius since the last report, SMART reports this.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/disk_update_1"
              }
            }
          }
        }
      }
    },
    "/disk/get_encrypted": {
      "post": {
        "tags": [
          "disk"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get all geli providers\n\nIt might be an entire disk or a partition of type freebsd-zfs.\n\nBefore a geli encrypted pool can be imported, disks used in the pool should be decrypted\nand then pool import can proceed as desired. In that case `unused` can be passed as `true`, to find out\nwhich disks are geli encrypted but not being used by active ZFS pools.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/disk_get_encrypted_0"
              }
            }
          }
        }
      }
    },
    "/disk/get_instance": {
      "get": {
        "tags": [
          "disk"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/disk/get_unused": {
      "post": {
        "tags": [
          "disk"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Helper method to get all disks that are not in use, either by the boot\npool or the user pools.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/disk_get_unused_0"
              }
            }
          }
        }
      }
    },
    "/disk/label_to_dev": {
      "get": {
        "tags": [
          "disk"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      }
    },
    "/disk/overprovision": {
      "post": {
        "tags": [
          "disk"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Sets overprovision of disk `devname` to `size` gigabytes",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/disk_overprovision"
              }
            }
          }
        }
      }
    },
    "/disk/smart_attributes": {
      "post": {
        "tags": [
          "disk"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns S.M.A.R.T. attributes values for specified disk name.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/disk_smart_attributes_0"
              }
            }
          }
        }
      }
    },
    "/disk/spindown": {
      "post": {
        "tags": [
          "disk"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Spin down disk by device name\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/disk_spindown_0"
              }
            }
          }
        }
      }
    },
    "/disk/temperature": {
      "post": {
        "tags": [
          "disk"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns temperature for device `name` using specified S.M.A.R.T. `powermode`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/disk_temperature"
              }
            }
          }
        }
      }
    },
    "/disk/temperatures": {
      "post": {
        "tags": [
          "disk"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns temperatures for a list of devices (runs in parallel).\nSee `disk.temperature` documentation for more details.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/disk_temperatures"
              }
            }
          }
        }
      }
    },
    "/disk/unoverprovision": {
      "post": {
        "tags": [
          "disk"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Removes overprovisioning of disk `devname`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/disk_unoverprovision_0"
              }
            }
          }
        }
      }
    },
    "/disk/wipe": {
      "post": {
        "tags": [
          "disk"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Performs a wipe of a disk `dev`.\nIt can be of the following modes:\n  - QUICK: clean the first few and last megabytes of every partition and disk\n  - FULL: write whole disk with zero's\n  - FULL_RANDOM: write whole disk with random bytes",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/disk_wipe"
              }
            }
          }
        }
      }
    },
    "/dns/query": {
      "get": {
        "tags": [
          "dns"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Query Name Servers with `query-filters` and `query-options`."
      }
    },
    "/dyndns": {
      "get": {
        "tags": [
          "dyndns"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "dyndns"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update dynamic dns service configuration.\n\n`period` indicates how often the IP is checked in seconds.\n\n`ssl` if set to true, makes sure that HTTPS is used for the connection to the server which updates the\nDNS record.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/dyndns_update_0"
              }
            }
          }
        }
      }
    },
    "/dyndns/provider_choices": {
      "get": {
        "tags": [
          "dyndns"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "List supported Dynamic DNS Service Providers."
      }
    },
    "/ec2/Meta": {
      "get": {
        "tags": [
          "ec2"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      }
    },
    "/ec2/instance_id": {
      "get": {
        "tags": [
          "ec2"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      }
    },
    "/ec2/set_ntp_servers": {
      "get": {
        "tags": [
          "ec2"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      }
    },
    "/ec2/set_root_ssh_public_key": {
      "get": {
        "tags": [
          "ec2"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      }
    },
    "/ec2/setup": {
      "get": {
        "tags": [
          "ec2"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      }
    },
    "/enclosure": {
      "get": {
        "tags": [
          "enclosure"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      }
    },
    "/enclosure/id/{id}": {
      "get": {
        "tags": [
          "enclosure"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "enclosure"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/enclosure_update_1"
              }
            }
          }
        }
      }
    },
    "/enclosure/get_instance": {
      "get": {
        "tags": [
          "enclosure"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/enclosure/set_slot_status": {
      "post": {
        "tags": [
          "enclosure"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/enclosure_set_slot_status"
              }
            }
          }
        }
      }
    },
    "/failover": {
      "get": {
        "tags": [
          "failover"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "failover"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update failover state.\n\n`disabled` when true indicates that HA is disabled.\n`master` sets the state of current node. Standby node will have the opposite value.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/failover_update_0"
              }
            }
          }
        }
      }
    },
    "/failover/call_remote": {
      "post": {
        "tags": [
          "failover"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Call a method in the other node.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/failover_call_remote"
              }
            }
          }
        }
      }
    },
    "/failover/control": {
      "post": {
        "tags": [
          "failover"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/failover_control"
              }
            }
          }
        }
      }
    },
    "/failover/force_master": {
      "get": {
        "tags": [
          "failover"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Force this controller to become MASTER."
      }
    },
    "/failover/hardware": {
      "get": {
        "tags": [
          "failover"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Gets the hardware type of HA.\n\n  ECHOSTREAM\n  ECHOWARP\n  PUMA\n  SBB\n  ULTIMATE\n  MANUAL"
      }
    },
    "/failover/in_progress": {
      "get": {
        "tags": [
          "failover"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns true if current node is still initializing after failover event"
      }
    },
    "/failover/licensed": {
      "get": {
        "tags": [
          "failover"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Checks whether this instance is licensed as a HA unit."
      }
    },
    "/failover/node": {
      "get": {
        "tags": [
          "failover"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Gets the node identification.\n  A - First node\n  B - Seconde Node\n  MANUAL - could not be identified, its in manual mode"
      }
    },
    "/failover/sync_from_peer": {
      "get": {
        "tags": [
          "failover"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Sync database and files from the other controller."
      }
    },
    "/failover/sync_to_peer": {
      "post": {
        "tags": [
          "failover"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Sync database and files to the other controller.\n\n`reboot` as true will reboot the other controller after syncing.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/failover_sync_to_peer_0"
              }
            }
          }
        }
      }
    },
    "/failover/unlock": {
      "post": {
        "tags": [
          "failover"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Unlock pools in HA, syncing passphrase between controllers and forcing this controller\nto be MASTER importing the pools.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/failover_unlock_0"
              }
            }
          }
        }
      }
    },
    "/failover/upgrade": {
      "post": {
        "tags": [
          "failover"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Upgrades both controllers.\n\nFiles will be downloaded to the Active Controller and then transferred to the Standby\nController.\n\nUpgrade process will start concurrently on both nodes.\n\nOnce both upgrades are applied, the Standby Controller will reboot. This job will wait for\nthat job to complete before finalizing.\n\nA file can be uploaded to this end point. This end point is special, please refer to Jobs section in Websocket API documentation for details.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/failover_upgrade_0"
              }
            }
          }
        }
      }
    },
    "/failover/upgrade_finish": {
      "get": {
        "tags": [
          "failover"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Perform the last stage of an HA upgrade.\n\nThis will activate the new boot environment on the\nStandby Controller and reboot it."
      }
    },
    "/failover/upgrade_pending": {
      "get": {
        "tags": [
          "failover"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Verify if HA upgrade is pending.\n\n`upgrade_finish` needs to be called to finish\nthe HA upgrade process if this method returns true."
      }
    },
    "/fcport": {
      "get": {
        "tags": [
          "fcport"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      }
    },
    "/fcport/id/{id}": {
      "get": {
        "tags": [
          "fcport"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "fcport"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/fcport_update_1"
              }
            }
          }
        }
      }
    },
    "/fcport/get_instance": {
      "get": {
        "tags": [
          "fcport"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/filesystem/acl_is_trivial": {
      "post": {
        "tags": [
          "filesystem"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns True if the ACL can be fully expressed as a file mode without losing\nany access rules, or if the path does not support NFSv4 ACLs (for example\na path on a tmpfs filesystem).",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/filesystem_acl_is_trivial_0"
              }
            }
          }
        }
      }
    },
    "/filesystem/chown": {
      "post": {
        "tags": [
          "filesystem"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Change owner or group of file at `path`.\n\n`uid` and `gid` specify new owner of the file. If either\nkey is absent or None, then existing value on the file is not\nchanged.\n\n`recursive` performs action recursively, but does\nnot traverse filesystem mount points.\n\nIf `traverse` and `recursive` are specified, then the chown\noperation will traverse filesystem mount points.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/filesystem_chown_0"
              }
            }
          }
        }
      }
    },
    "/filesystem/default_acl_choices": {
      "get": {
        "tags": [
          "filesystem"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get list of default ACL types."
      }
    },
    "/filesystem/get_default_acl": {
      "post": {
        "tags": [
          "filesystem"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns a default ACL depending on the usage specified by `acl_type`.\nIf an admin group is defined, then an entry granting it full control will\nbe placed at the top of the ACL. Optionally may pass `share_type` to argument\nto get share-specific template ACL.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/filesystem_get_default_acl"
              }
            }
          }
        }
      }
    },
    "/filesystem/getacl": {
      "post": {
        "tags": [
          "filesystem"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Return ACL of a given path.\n\nSimplified returns a shortened form of the ACL permset and flags\n\n`TRAVERSE` sufficient rights to traverse a directory, but not read contents.\n\n`READ` sufficient rights to traverse a directory, and read file contents.\n\n`MODIFIY` sufficient rights to traverse, read, write, and modify a file. Equivalent to modify_set.\n\n`FULL_CONTROL` all permissions.\n\nIf the permisssions do not fit within one of the pre-defined simplified permissions types, then\nthe full ACL entry will be returned.\n\nIn all cases we replace USER_OBJ, GROUP_OBJ, and EVERYONE with owner@, group@, everyone@ for\nconsistency with getfacl and setfacl. If one of aforementioned special tags is used, 'id' must\nbe set to None.\n\nAn inheriting empty everyone@ ACE is appended to non-trivial ACLs in order to enforce Windows\nexpectations regarding permissions inheritance. This entry is removed from NT ACL returned\nto SMB clients when 'ixnas' samba VFS module is enabled. We also remove it here to avoid confusion.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/filesystem_getacl"
              }
            }
          }
        }
      }
    },
    "/filesystem/listdir": {
      "post": {
        "tags": [
          "filesystem"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get the contents of a directory.\n\nEach entry of the list consists of:\n  name(str): name of the file\n  path(str): absolute path of the entry\n  realpath(str): absolute real path of the entry (if SYMLINK)\n  type(str): DIRECTORY | FILESYSTEM | SYMLINK | OTHER\n  size(int): size of the entry\n  mode(int): file mode/permission\n  uid(int): user id of entry owner\n  gid(int): group id of entry onwer\n  acl(bool): extended ACL is present on file",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/filesystem_listdir"
              }
            }
          }
        }
      }
    },
    "/filesystem/setacl": {
      "post": {
        "tags": [
          "filesystem"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Set ACL of a given path. Takes the following parameters:\n`path` full path to directory or file.\n\n`dacl` \"simplified\" ACL here or a full ACL.\n\n`uid` the desired UID of the file user. If set to None (the default), then user is not changed.\n\n`gid` the desired GID of the file group. If set to None (the default), then group is not changed.\n\n`recursive` apply the ACL recursively\n\n`traverse` traverse filestem boundaries (ZFS datasets)\n\n`strip` convert ACL to trivial. ACL is trivial if it can be expressed as a file mode without\nlosing any access rules.\n\n`canonicalize` reorder ACL entries so that they are in concanical form as described\nin the Microsoft documentation MS-DTYP 2.4.5 (ACL)\n\nIn all cases we replace USER_OBJ, GROUP_OBJ, and EVERYONE with owner@, group@, everyone@ for\nconsistency with getfacl and setfacl. If one of aforementioned special tags is used, 'id' must\nbe set to None.\n\nAn inheriting empty everyone@ ACE is appended to non-trivial ACLs in order to enforce Windows\nexpectations regarding permissions inheritance. This entry is removed from NT ACL returned\nto SMB clients when 'ixnas' samba VFS module is enabled.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/filesystem_setacl_0"
              }
            }
          }
        }
      }
    },
    "/filesystem/setperm": {
      "post": {
        "tags": [
          "filesystem"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Remove extended ACL from specified path.\n\nIf `mode` is specified then the mode will be applied to the\npath and files and subdirectories depending on which `options` are\nselected. Mode should be formatted as string representation of octal\npermissions bits.\n\n`uid` the desired UID of the file user. If set to None (the default), then user is not changed.\n\n`gid` the desired GID of the file group. If set to None (the default), then group is not changed.\n\n`stripacl` setperm will fail if an extended ACL is present on `path`,\nunless `stripacl` is set to True.\n\n`recursive` remove ACLs recursively, but do not traverse dataset\nboundaries.\n\n`traverse` remove ACLs from child datasets.\n\nIf no `mode` is set, and `stripacl` is True, then non-trivial ACLs\nwill be converted to trivial ACLs. An ACL is trivial if it can be\nexpressed as a file mode without losing any access rules.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/filesystem_setperm_0"
              }
            }
          }
        }
      }
    },
    "/filesystem/stat": {
      "post": {
        "tags": [
          "filesystem"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Return the filesystem stat(2) for a given `path`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/filesystem_stat_0"
              }
            }
          }
        }
      }
    },
    "/filesystem/statfs": {
      "post": {
        "tags": [
          "filesystem"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Return stats from the filesystem of a given path.\n\nRaises:\n    CallError(ENOENT) - Path not found",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/filesystem_statfs_0"
              }
            }
          }
        }
      }
    },
    "/ftp": {
      "get": {
        "tags": [
          "ftp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "ftp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update ftp service configuration.\n\n`clients` is an integer value which sets the maximum number of simultaneous clients allowed. It defaults to 32.\n\n`ipconnections` is an integer value which shows the maximum number of connections per IP address. It defaults\nto 0 which equals to unlimited.\n\n`timeout` is the maximum client idle time in seconds before client is disconnected.\n\n`rootlogin` is a boolean value which when configured to true enables login as root. This is generally\ndiscouraged because of the security risks.\n\n`onlyanonymous` allows anonymous FTP logins with access to the directory specified by `anonpath`.\n\n`banner` is a message displayed to local login users after they successfully authenticate. It is not displayed\nto anonymous login users.\n\n`filemask` sets the default permissions for newly created files which by default are 077.\n\n`dirmask` sets the default permissions for newly created directories which by default are 077.\n\n`resume` if set allows FTP clients to resume interrupted transfers.\n\n`fxp` if set to true indicates that File eXchange Protocol is enabled. Generally it is discouraged as it\nmakes the server vulnerable to FTP bounce attacks.\n\n`defaultroot` when set ensures that for local users, home directory access is only granted if the user\nis a member of group wheel.\n\n`ident` is a boolean value which when set to true indicates that IDENT authentication is required. If identd\nis not running on the client, this can result in timeouts.\n\n`masqaddress` is the public IP address or hostname which is set if FTP clients cannot connect through a\nNAT device.\n\n`localuserbw` is a positive integer value which indicates maximum upload bandwidth in KB/s for local user.\nDefault of zero indicates unlimited upload bandwidth ( from the FTP server configuration ).\n\n`localuserdlbw` is a positive integer value which indicates maximum download bandwidth in KB/s for local user.\nDefault of zero indicates unlimited download bandwidth ( from the FTP server configuration ).\n\n`anonuserbw` is a positive integer value which indicates maximum upload bandwidth in KB/s for anonymous user.\nDefault of zero indicates unlimited upload bandwidth ( from the FTP server configuration ).\n\n`anonuserdlbw` is a positive integer value which indicates maximum download bandwidth in KB/s for anonymous\nuser. Default of zero indicates unlimited download bandwidth ( from the FTP server configuration ).\n\n`tls` is a boolean value which when set indicates that encrypted connections are enabled. This requires a\ncertificate to be configured first with the certificate service and the id of certificate is passed on in\n`ssltls_certificate`.\n\n`tls_policy` defines whether the control channel, data channel, both channels, or neither channel of an FTP\nsession must occur over SSL/TLS.\n\n`tls_opt_enable_diags` is a boolean value when set, logs verbosely. This is helpful when troubleshooting a\nconnection.\n\n`options` is a string used to add proftpd(8) parameters not covered by ftp service.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ftp_update_0"
              }
            }
          }
        }
      }
    },
    "/group": {
      "get": {
        "tags": [
          "group"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Query groups with `query-filters` and `query-options`. As a performance optimization, only local groups\nwill be queried by default.\n\nGroups from directory services such as NIS, LDAP, or Active Directory will be included in query results\nif the option `{'extra': {'search_dscache': True}}` is specified."
      },
      "post": {
        "tags": [
          "group"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a new group.\n\nIf `gid` is not provided it is automatically filled with the next one available.\n\n`allow_duplicate_gid` allows distinct group names to share the same gid.\n\n`users` is a list of user ids (`id` attribute from `user.query`).\n\n`smb` specifies whether the group should be mapped into an NT group.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/group_create_0"
              }
            }
          }
        }
      }
    },
    "/group/id/{id}": {
      "delete": {
        "tags": [
          "group"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete group `id`.\n\nThe `delete_users` option deletes all users that have this group as their primary group.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/group_delete_1"
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "group"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ],
        "description": "Query groups with `query-filters` and `query-options`. As a performance optimization, only local groups\nwill be queried by default.\n\nGroups from directory services such as NIS, LDAP, or Active Directory will be included in query results\nif the option `{'extra': {'search_dscache': True}}` is specified."
      },
      "put": {
        "tags": [
          "group"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update attributes of an existing group.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/group_update_1"
              }
            }
          }
        }
      }
    },
    "/group/get_group_obj": {
      "post": {
        "tags": [
          "group"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns dictionary containing information from struct grp for the group specified by either\nthe groupname or gid. Bypasses group cache.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/group_get_group_obj_0"
              }
            }
          }
        }
      }
    },
    "/group/get_instance": {
      "get": {
        "tags": [
          "group"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/group/get_next_gid": {
      "get": {
        "tags": [
          "group"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get the next available/free gid."
      }
    },
    "/idmap": {
      "get": {
        "tags": [
          "idmap"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "idmap"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a new IDMAP domain. These domains must be unique. This table\nwill be automatically populated after joining an Active Directory domain\nif \"allow trusted domains\" is set to True in the AD service configuration.\nThere are three default system domains: DS_TYPE_ACTIVEDIRECTORY, DS_TYPE_LDAP, DS_TYPE_DEFAULT_DOMAIN.\nThe system domains correspond with the idmap settings under Active Directory, LDAP, and SMB\nrespectively.\n\n`name` the pre-windows 2000 domain name.\n\n`DNS_domain_name` DNS name of the domain.\n\n`idmap_backend` provides a plugin interface for Winbind to use varying\nbackends to store SID/uid/gid mapping tables. The correct setting\ndepends on the environment in which the NAS is deployed.\n\n`range_low` and `range_high` specify the UID and GID range for which this backend is authoritative.\n\n`certificate_id` references the certificate ID of the SSL certificate to use for certificate-based\nauthentication to a remote LDAP server. This parameter is not supported for all idmap backends as some\nbackends will generate SID to ID mappings algorithmically without causing network traffic.\n\n`options` are additional parameters that are backend-dependent:\n\n`AD` idmap backend options:\n`unix_primary_group` If True, the primary group membership is fetched from the LDAP attributes (gidNumber).\nIf False, the primary group membership is calculated via the \"primaryGroupID\" LDAP attribute.\n\n`unix_nss_info` if True winbind will retrieve the login shell and home directory from the LDAP attributes.\nIf False or if the AD LDAP entry lacks the SFU attributes the smb4.conf parameters `template shell` and `template homedir` are used.\n\n`schema_mode` Defines the schema that idmap_ad should use when querying Active Directory regarding user and group information.\nThis can be either the RFC2307 schema support included in Windows 2003 R2 or the Service for Unix (SFU) schema.\nFor SFU 3.0 or 3.5 please choose \"SFU\", for SFU 2.0 please choose \"SFU20\". The behavior of primary group membership is\ncontrolled by the unix_primary_group option.\n\n`AUTORID` idmap backend options:\n`readonly` sets the module to read-only mode. No new ranges will be allocated and new mappings\nwill not be created in the idmap pool.\n\n`ignore_builtin` ignores mapping requests for the BUILTIN domain.\n\n`LDAP` idmap backend options:\n`ldap_base_dn` defines the directory base suffix to use for SID/uid/gid mapping entries.\n\n`ldap_user_dn` defines the user DN to be used for authentication.\n\n`ldap_url` specifies the LDAP server to use for SID/uid/gid map entries.\n\n`ssl` specifies whether to encrypt the LDAP transport for the idmap backend.\n\n`NSS` idmap backend options:\n`linked_service` specifies the auxiliary directory service ID provider.\n\n`RFC2307` idmap backend options:\n`domain` specifies the domain for which the idmap backend is being created. Numeric id, short-form\ndomain name, or long-form DNS domain name of the domain may be specified. Entry must be entered as\nit appears in `idmap.domain`.\n\n`range_low` and `range_high` specify the UID and GID range for which this backend is authoritative.\n\n`ldap_server` defines the type of LDAP server to use. This can either be an LDAP server provided\nby the Active Directory Domain (ad) or a stand-alone LDAP server.\n\n`bind_path_user` specfies the search base where user objects can be found in the LDAP server.\n\n`bind_path_group` specifies the search base where group objects can be found in the LDAP server.\n\n`user_cn` query cn attribute instead of uid attribute for the user name in LDAP.\n\n`realm` append @realm to cn for groups (and users if user_cn is set) in LDAP queries.\n\n`ldmap_domain` when using the LDAP server in the Active Directory server, this allows one to\nspecify the domain where to access the Active Directory server. This allows using trust relationships\nwhile keeping all RFC 2307 records in one place. This parameter is optional, the default is to access\nthe AD server in the current domain to query LDAP records.\n\n`ldap_url` when using a stand-alone LDAP server, this parameter specifies the LDAP URL for accessing the LDAP server.\n\n`ldap_user_dn` defines the user DN to be used for authentication.\n\n`realm` defines the realm to use in the user and group names. This is only required when using cn_realm together with\n a stand-alone ldap server.\n\n`RID` backend options:\n`sssd_compat` generate idmap low range based on same algorithm that SSSD uses by default.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/idmap_create_0"
              }
            }
          }
        }
      }
    },
    "/idmap/id/{id}": {
      "delete": {
        "tags": [
          "idmap"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete a domain by id. Deletion of default system domains is not permitted."
      },
      "get": {
        "tags": [
          "idmap"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "idmap"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update a domain by id.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/idmap_update_1"
              }
            }
          }
        }
      }
    },
    "/idmap/backend_choices": {
      "get": {
        "tags": [
          "idmap"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns array of valid idmap backend choices per directory service."
      }
    },
    "/idmap/backend_options": {
      "get": {
        "tags": [
          "idmap"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "This returns full information about idmap backend options. Not all\n`options` are valid for every backend."
      }
    },
    "/idmap/clear_idmap_cache": {
      "get": {
        "tags": [
          "idmap"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Stop samba, remove the winbindd_cache.tdb file, start samba, flush samba's cache.\nThis should be performed after finalizing idmap changes."
      }
    },
    "/idmap/get_instance": {
      "get": {
        "tags": [
          "idmap"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/idmap/options_choices": {
      "post": {
        "tags": [
          "idmap"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns a list of supported keys for the specified idmap backend.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/idmap_options_choices_0"
              }
            }
          }
        }
      }
    },
    "/initshutdownscript": {
      "get": {
        "tags": [
          "initshutdownscript"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "initshutdownscript"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create an initshutdown script task.\n\n`type` indicates if a command or script should be executed at `when`.\n\nThere are three choices for `when`:\n\n1) PREINIT - This is early in the boot process before all the services / rc scripts have started\n2) POSTINIT - This is late in the boot process when most of the services / rc scripts have started\n3) SHUTDOWN - This is on shutdown\n\n`timeout` is an integer value which indicates time in seconds which the system should wait for the execution\nof script/command. It should be noted that a hard limit for a timeout is configured by the base OS, so when\na script/command is set to execute on SHUTDOWN, the hard limit configured by the base OS is changed adding\nthe timeout specified by script/command so it can be ensured that it executes as desired and is not interrupted\nby the base OS's limit.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/initshutdownscript_create_0"
              }
            }
          }
        }
      }
    },
    "/initshutdownscript/id/{id}": {
      "delete": {
        "tags": [
          "initshutdownscript"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete init/shutdown task of `id`."
      },
      "get": {
        "tags": [
          "initshutdownscript"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "initshutdownscript"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update initshutdown script task of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/initshutdownscript_update_1"
              }
            }
          }
        }
      }
    },
    "/initshutdownscript/get_instance": {
      "get": {
        "tags": [
          "initshutdownscript"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/interface": {
      "get": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Query Interfaces with `query-filters` and `query-options`"
      },
      "post": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create virtual interfaces (Link Aggregation, VLAN)\n\nFor BRIDGE `type` the following attribute is required: bridge_members.\n\nFor LINK_AGGREGATION `type` the following attributes are required: lag_ports,\nlag_protocol.\n\nFor VLAN `type` the following attributes are required: vlan_parent_interface,\nvlan_tag and vlan_pcp.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/interface_create_0"
              }
            }
          }
        }
      }
    },
    "/interface/id/{id}": {
      "delete": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Delete Interface of `id`."
      },
      "get": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ],
        "description": "Query Interfaces with `query-filters` and `query-options`"
      },
      "put": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Update Interface of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/interface_update_1"
              }
            }
          }
        }
      }
    },
    "/interface/bridge_members_choices": {
      "post": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Return available interface choices for `bridge_members` attribute.\n\n`id` is the name of the bridge interface to update or null for a new\nbridge interface.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/interface_bridge_members_choices_0"
              }
            }
          }
        }
      }
    },
    "/interface/bridge_setup": {
      "get": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      }
    },
    "/interface/checkin": {
      "get": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "After interfaces changes are committed with checkin timeout this method needs to be called\nwithin that timeout limit to prevent reverting the changes.\n\nThis is to ensure user verifies the changes went as planned and its working."
      }
    },
    "/interface/checkin_waiting": {
      "get": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns wether or not we are waiting user to checkin the applied network changes\nbefore they are rolled back.\nValue is in number of seconds or null."
      }
    },
    "/interface/choices": {
      "post": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Choices of available network interfaces.\n\n`bridge_members` will include BRIDGE members.\n`lag_ports` will include LINK_AGGREGATION ports.\n`vlan_parent` will include VLAN parent interface.\n`exclude` is a list of interfaces prefix to remove.\n`include` is a list of interfaces that should not be removed.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/interface_choices_0"
              }
            }
          }
        }
      }
    },
    "/interface/commit": {
      "post": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Commit/apply pending interfaces changes.\n\n`rollback` as true (default) will rollback changes in case they fail to apply.\n`checkin_timeout` is the time in seconds it will wait for the checkin call to acknowledge\nthe interfaces changes happened as planned from the user. If checkin does not happen\nwithin this period of time the changes will get reverted.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/interface_commit_0"
              }
            }
          }
        }
      }
    },
    "/interface/get_instance": {
      "get": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/interface/has_pending_changes": {
      "get": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns whether there are pending interfaces changes to be applied or not."
      }
    },
    "/interface/ip_in_use": {
      "post": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get all IPv4 / Ipv6 from all valid interfaces, excluding tap and epair.\n\n`loopback` will return loopback interface addresses.\n\n`any` will return wildcard addresses (0.0.0.0 and ::).\n\n`static` when enabled will ensure we only return static ip's configured.\n\nReturns a list of dicts - eg -\n\n[\n    {\n        \"type\": \"INET6\",\n        \"address\": \"fe80::5054:ff:fe16:4aac\",\n        \"netmask\": 64\n    },\n    {\n        \"type\": \"INET\",\n        \"address\": \"192.168.122.148\",\n        \"netmask\": 24,\n        \"broadcast\": \"192.168.122.255\"\n    },\n]",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/interface_ip_in_use_0"
              }
            }
          }
        }
      }
    },
    "/interface/lag_ports_choices": {
      "post": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Return available interface choices for `lag_ports` attribute.\n\n`id` is the name of the LAG interface to update or null for a new\nLAG interface.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/interface_lag_ports_choices_0"
              }
            }
          }
        }
      }
    },
    "/interface/lag_setup": {
      "get": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      }
    },
    "/interface/rollback": {
      "get": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Rollback pending interfaces changes."
      }
    },
    "/interface/vlan_parent_interface_choices": {
      "get": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Return available interface choices for `vlan_parent_interface` attribute."
      }
    },
    "/interface/vlan_setup": {
      "get": {
        "tags": [
          "interface"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      }
    },
    "/ipmi": {
      "get": {
        "tags": [
          "ipmi"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Query all IPMI Channels with `query-filters` and `query-options`."
      }
    },
    "/ipmi/id/{id}": {
      "get": {
        "tags": [
          "ipmi"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ],
        "description": "Query all IPMI Channels with `query-filters` and `query-options`."
      },
      "put": {
        "tags": [
          "ipmi"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "channel"
            }
          }
        ],
        "description": "Update `id` IPMI Configuration.\n\n`ipaddress` is a valid ip which will be used to connect to the IPMI interface.\n\n`netmask` is the subnet mask associated with `ipaddress`.\n\n`dhcp` is a boolean value which if unset means that `ipaddress`, `netmask` and `gateway` must be set.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ipmi_update_1"
              }
            }
          }
        }
      }
    },
    "/ipmi/channels": {
      "get": {
        "tags": [
          "ipmi"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Return a list with the IPMI channels available."
      }
    },
    "/ipmi/get_instance": {
      "get": {
        "tags": [
          "ipmi"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/ipmi/identify": {
      "post": {
        "tags": [
          "ipmi"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Turn on IPMI chassis identify light.\n\nTo turn off specify 0 as `seconds`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ipmi_identify_0"
              }
            }
          }
        }
      }
    },
    "/ipmi/is_loaded": {
      "get": {
        "tags": [
          "ipmi"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns a boolean true value indicating if ipmi device is loaded."
      }
    },
    "/iscsi/auth": {
      "get": {
        "tags": [
          "iscsi.auth"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "iscsi.auth"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create an iSCSI Authorized Access.\n\n`tag` should be unique among all configured iSCSI Authorized Accesses.\n\n`secret` and `peersecret` should have length between 12-16 letters inclusive.\n\n`peeruser` and `peersecret` are provided only when configuring mutual CHAP. `peersecret` should not be\nsimilar to `secret`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iscsi_auth_create_0"
              }
            }
          }
        }
      }
    },
    "/iscsi/auth/id/{id}": {
      "delete": {
        "tags": [
          "iscsi.auth"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete iSCSI Authorized Access of `id`."
      },
      "get": {
        "tags": [
          "iscsi.auth"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "iscsi.auth"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update iSCSI Authorized Access of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iscsi_auth_update_1"
              }
            }
          }
        }
      }
    },
    "/iscsi/auth/get_instance": {
      "get": {
        "tags": [
          "iscsi.auth"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/iscsi/extent": {
      "get": {
        "tags": [
          "iscsi.extent"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "iscsi.extent"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create an iSCSI Extent.\n\nWhen `type` is set to FILE, attribute `filesize` is used and it represents number of bytes. `filesize` if\nnot zero should be a multiple of `blocksize`. `path` is a required attribute with `type` set as FILE and it\nshould be ensured that it does not come under a jail root.\n\nWith `type` being set to DISK, a valid ZVOL or DISK should be provided.\n\n`insecure_tpc` when enabled allows an initiator to bypass normal access control and access any scannable\ntarget. This allows xcopy operations otherwise blocked by access control.\n\n`xen` is a boolean value which is set to true if Xen is being used as the iSCSI initiator.\n\n`ro` when set to true prevents the initiator from writing to this LUN.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iscsi_extent_create_0"
              }
            }
          }
        }
      }
    },
    "/iscsi/extent/id/{id}": {
      "delete": {
        "tags": [
          "iscsi.extent"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete iSCSI Extent of `id`.\n\nIf `id` iSCSI Extent's `type` was configured to FILE, `remove` can be set to remove the configured file.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iscsi_extent_delete"
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "iscsi.extent"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "iscsi.extent"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update iSCSI Extent of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iscsi_extent_update_1"
              }
            }
          }
        }
      }
    },
    "/iscsi/extent/disk_choices": {
      "post": {
        "tags": [
          "iscsi.extent"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Exclude will exclude the path from being in the used_zvols list,\nallowing the user to keep the same item on update",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iscsi_extent_disk_choices_0"
              }
            }
          }
        }
      }
    },
    "/iscsi/extent/get_instance": {
      "get": {
        "tags": [
          "iscsi.extent"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/iscsi/global": {
      "get": {
        "tags": [
          "iscsi.global"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "iscsi.global"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "`alua` is a no-op for FreeNAS.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iscsi_global_update_0"
              }
            }
          }
        }
      }
    },
    "/iscsi/global/alua_enabled": {
      "get": {
        "tags": [
          "iscsi.global"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns whether iSCSI ALUA is enabled or not."
      }
    },
    "/iscsi/global/sessions": {
      "get": {
        "tags": [
          "iscsi.global"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Get a list of currently running iSCSI sessions. This includes initiator and target names\nand the unique connection IDs."
      }
    },
    "/iscsi/initiator": {
      "get": {
        "tags": [
          "iscsi.initiator"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "iscsi.initiator"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create an iSCSI Initiator.\n\n`initiators` is a list of initiator hostnames which are authorized to access an iSCSI Target. To allow all\npossible initiators, `initiators` can be left empty.\n\n`auth_network` is a list of IP/CIDR addresses which are allowed to use this initiator. If all networks are\nto be allowed, this field should be left empty.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iscsi_initiator_create_0"
              }
            }
          }
        }
      }
    },
    "/iscsi/initiator/id/{id}": {
      "delete": {
        "tags": [
          "iscsi.initiator"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete iSCSI initiator of `id`."
      },
      "get": {
        "tags": [
          "iscsi.initiator"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "iscsi.initiator"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update iSCSI initiator of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iscsi_initiator_update_1"
              }
            }
          }
        }
      }
    },
    "/iscsi/initiator/get_instance": {
      "get": {
        "tags": [
          "iscsi.initiator"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/iscsi/portal": {
      "get": {
        "tags": [
          "iscsi.portal"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "iscsi.portal"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a new iSCSI Portal.\n\n`discovery_authgroup` is required for CHAP and CHAP_MUTUAL.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iscsi_portal_create_0"
              }
            }
          }
        }
      }
    },
    "/iscsi/portal/id/{id}": {
      "delete": {
        "tags": [
          "iscsi.portal"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete iSCSI Portal `id`."
      },
      "get": {
        "tags": [
          "iscsi.portal"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "iscsi.portal"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update iSCSI Portal `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iscsi_portal_update_1"
              }
            }
          }
        }
      }
    },
    "/iscsi/portal/get_instance": {
      "get": {
        "tags": [
          "iscsi.portal"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/iscsi/portal/listen_ip_choices": {
      "get": {
        "tags": [
          "iscsi.portal"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns possible choices for `listen.ip` attribute of portal create and update."
      }
    },
    "/iscsi/target": {
      "get": {
        "tags": [
          "iscsi.target"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "iscsi.target"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create an iSCSI Target.\n\n`groups` is a list of group dictionaries which provide information related to using a `portal`, `initiator`,\n`authmethod` and `auth` with this target. `auth` represents a valid iSCSI Authorized Access and defaults to\nnull.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iscsi_target_create_0"
              }
            }
          }
        }
      }
    },
    "/iscsi/target/id/{id}": {
      "delete": {
        "tags": [
          "iscsi.target"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete iSCSI Target of `id`.\n\nDeleting an iSCSI Target makes sure we delete all Associated Targets which use `id` iSCSI Target.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iscsi_target_delete_1"
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "iscsi.target"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "iscsi.target"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update iSCSI Target of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iscsi_target_update_1"
              }
            }
          }
        }
      }
    },
    "/iscsi/target/get_instance": {
      "get": {
        "tags": [
          "iscsi.target"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/iscsi/targetextent": {
      "get": {
        "tags": [
          "iscsi.targetextent"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "iscsi.targetextent"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create an Associated Target.\n\n`lunid` will be automatically assigned if it is not provided based on the `target`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iscsi_targetextent_create_0"
              }
            }
          }
        }
      }
    },
    "/iscsi/targetextent/id/{id}": {
      "delete": {
        "tags": [
          "iscsi.targetextent"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete Associated Target of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iscsi_targetextent_delete_1"
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "iscsi.targetextent"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "iscsi.targetextent"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update Associated Target of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iscsi_targetextent_update_1"
              }
            }
          }
        }
      }
    },
    "/iscsi/targetextent/get_instance": {
      "get": {
        "tags": [
          "iscsi.targetextent"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/jail": {
      "get": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Query all jails with `query-filters` and `query-options`."
      },
      "post": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Creates a jail.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_create_0"
              }
            }
          }
        }
      }
    },
    "/jail/id/{id}": {
      "delete": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "jail",
              "type": "string"
            }
          }
        ],
        "description": "Takes a jail and destroys it.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_delete_1"
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ],
        "description": "Query all jails with `query-filters` and `query-options`."
      },
      "put": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "jail",
              "type": "string"
            }
          }
        ],
        "description": "Sets a jail property.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_update_1"
              }
            }
          }
        }
      }
    },
    "/jail/activate": {
      "post": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Activates a pool for iocage usage, and deactivates the rest.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_activate_0"
              }
            }
          }
        }
      }
    },
    "/jail/clean": {
      "post": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Cleans all iocage datasets of ds_type",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_clean_0"
              }
            }
          }
        }
      }
    },
    "/jail/id/{id}/clone": {
      "post": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "source_jail",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_clone_1"
              }
            }
          }
        }
      }
    },
    "/jail/default_configuration": {
      "get": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Retrieve default configuration for iocage jails."
      }
    },
    "/jail/exec": {
      "post": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Issues a command inside a jail.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_exec"
              }
            }
          }
        }
      }
    },
    "/jail/export": {
      "post": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Export jail to compressed file.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_export_0"
              }
            }
          }
        }
      }
    },
    "/jail/fetch": {
      "post": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Fetches a release or plugin.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_fetch_0"
              }
            }
          }
        }
      }
    },
    "/jail/fstab": {
      "post": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Manipulate a jails fstab",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_fstab"
              }
            }
          }
        }
      }
    },
    "/jail/get_activated_pool": {
      "get": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns the activated pool if there is one, or None"
      }
    },
    "/jail/get_instance": {
      "get": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/jail/import_image": {
      "post": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Import jail from compressed file.\n\n`compression algorithm`: None indicates that middlewared is to automatically determine\nwhich compression algorithm to use based on the compressed file extension. If multiple copies are found, an\nexception is raised.\n\n`path` is the directory where the exported jail lives. It defaults to the iocage images dataset.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_import_image_0"
              }
            }
          }
        }
      }
    },
    "/jail/interface_choices": {
      "get": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns a dictionary of interface choices which can be used with creating/updating jails."
      }
    },
    "/jail/rc_action": {
      "post": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Does specified action on rc enabled (boot=on) jails",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_rc_action_0"
              }
            }
          }
        }
      }
    },
    "/jail/releases_choices": {
      "post": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "List installed or available releases which can be downloaded.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_releases_choices_0"
              }
            }
          }
        }
      }
    },
    "/jail/restart": {
      "post": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Takes a jail and restarts it.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_restart_0"
              }
            }
          }
        }
      }
    },
    "/jail/start": {
      "post": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Takes a jail and starts it.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_start_0"
              }
            }
          }
        }
      }
    },
    "/jail/stop": {
      "post": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Takes a jail and stops it.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_stop"
              }
            }
          }
        }
      }
    },
    "/jail/update_defaults": {
      "post": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update default properties for iocage which will remain true for all jails moving on i.e nat_backend",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_update_defaults_0"
              }
            }
          }
        }
      }
    },
    "/jail/update_to_latest_patch": {
      "post": {
        "tags": [
          "jail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Updates specified jail to latest patch level.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/jail_update_to_latest_patch"
              }
            }
          }
        }
      }
    },
    "/kerberos": {
      "get": {
        "tags": [
          "kerberos"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "kerberos"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "`appdefaults_aux` add parameters to \"appdefaults\" section of the krb5.conf file.\n\n`libdefaults_aux` add parameters to \"libdefaults\" section of the krb5.conf file.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/kerberos_update_0"
              }
            }
          }
        }
      }
    },
    "/kerberos/keytab": {
      "get": {
        "tags": [
          "kerberos.keytab"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "kerberos.keytab"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a kerberos keytab. Uploaded keytab files will be merged with the system\nkeytab under /etc/krb5.keytab.\n\n`file` b64encoded kerberos keytab\n`name` name for kerberos keytab",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/kerberos_keytab_create_0"
              }
            }
          }
        }
      }
    },
    "/kerberos/keytab/id/{id}": {
      "delete": {
        "tags": [
          "kerberos.keytab"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete kerberos keytab by id, and force regeneration of\nsystem keytab."
      },
      "get": {
        "tags": [
          "kerberos.keytab"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "kerberos.keytab"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update kerberos keytab by id.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/kerberos_keytab_update_1"
              }
            }
          }
        }
      }
    },
    "/kerberos/keytab/get_instance": {
      "get": {
        "tags": [
          "kerberos.keytab"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/kerberos/keytab/system_keytab_list": {
      "get": {
        "tags": [
          "kerberos.keytab"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns content of system keytab (/etc/krb5.keytab)."
      }
    },
    "/kerberos/realm": {
      "get": {
        "tags": [
          "kerberos.realm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "kerberos.realm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a new kerberos realm. This will be automatically populated during the\ndomain join process in an Active Directory environment. Kerberos realm names\nare case-sensitive, but convention is to only use upper-case.\n\nEntries for kdc, admin_server, and kpasswd_server are not required.\nIf they are unpopulated, then kerberos will use DNS srv records to\ndiscover the correct servers. The option to hard-code them is provided\ndue to AD site discovery. Kerberos has no concept of Active Directory\nsites. This means that middleware performs the site discovery and\nsets the kerberos configuration based on the AD site.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/kerberos_realm_create_0"
              }
            }
          }
        }
      }
    },
    "/kerberos/realm/id/{id}": {
      "delete": {
        "tags": [
          "kerberos.realm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete a kerberos realm by ID."
      },
      "get": {
        "tags": [
          "kerberos.realm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "kerberos.realm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update a kerberos realm by id. This will be automatically populated during the\ndomain join process in an Active Directory environment. Kerberos realm names\nare case-sensitive, but convention is to only use upper-case.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/kerberos_realm_update_1"
              }
            }
          }
        }
      }
    },
    "/kerberos/realm/get_instance": {
      "get": {
        "tags": [
          "kerberos.realm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/keychaincredential": {
      "get": {
        "tags": [
          "keychaincredential"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "keychaincredential"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a Keychain Credential\n\nCreate a Keychain Credential of any type.\nEvery Keychain Credential has a `name` which is used to distinguish it from others.\nThe following `type`s are supported:\n * `SSH_KEY_PAIR`\n   Which `attributes` are:\n   * `private_key`\n   * `public_key` (which can be omitted and thus automatically derived from private key)\n   At least one attribute is required.\n\n * `SSH_CREDENTIALS`\n   Which `attributes` are:\n   * `host`\n   * `port` (default 22)\n   * `username` (default root)\n   * `private_key` (Keychain Credential ID)\n   * `remote_host_key` (you can use `keychaincredential.remote_ssh_host_key_scan` do discover it)\n   * `cipher`: one of `STANDARD`, `FAST`, or `DISABLED` (last requires special support from both SSH server and\n     client)\n   * `connect_timeout` (default 10)\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/keychaincredential_create_0"
              }
            }
          }
        }
      }
    },
    "/keychaincredential/id/{id}": {
      "delete": {
        "tags": [
          "keychaincredential"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete Keychain Credential with specific `id`\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/keychaincredential_delete_1"
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "keychaincredential"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "keychaincredential"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update a Keychain Credential with specific `id`\n\nPlease note that you can't change `type`\n\nAlso you must specify full `attributes` value\n\nSee the documentation for `create` method for information on payload contents\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/keychaincredential_update_1"
              }
            }
          }
        }
      }
    },
    "/keychaincredential/generate_ssh_key_pair": {
      "get": {
        "tags": [
          "keychaincredential"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Generate a public/private key pair\n\nGenerate a public/private key pair (useful for `SSH_KEY_PAIR` type)\n\n"
      }
    },
    "/keychaincredential/get_instance": {
      "get": {
        "tags": [
          "keychaincredential"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/keychaincredential/remote_ssh_host_key_scan": {
      "post": {
        "tags": [
          "keychaincredential"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Discover a remote host key\n\nDiscover a remote host key (useful for `SSH_CREDENTIALS`)\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/keychaincredential_remote_ssh_host_key_scan_0"
              }
            }
          }
        }
      }
    },
    "/keychaincredential/remote_ssh_semiautomatic_setup": {
      "post": {
        "tags": [
          "keychaincredential"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Perform semi-automatic SSH connection setup with other FreeNAS machine\n\nPerform semi-automatic SSH connection setup with other FreeNAS machine. It creates a `SSH_CREDENTIALS`\ncredential with specified `name` that can be used to connect to FreeNAS machine with specified `url` and\ntemporary auth `token`. Other FreeNAS machine adds `private_key` to allowed `username`'s private keys. Other\n`SSH_CREDENTIALS` attributes such as `cipher` and `connect_timeout` can be specified as well.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/keychaincredential_remote_ssh_semiautomatic_setup_0"
              }
            }
          }
        }
      }
    },
    "/keychaincredential/used_by": {
      "post": {
        "tags": [
          "keychaincredential"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns list of objects that use this credential.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/keychaincredential_used_by_0"
              }
            }
          }
        }
      }
    },
    "/kmip": {
      "get": {
        "tags": [
          "kmip"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "kmip"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update KMIP Server Configuration.\n\nSystem currently authenticates connection with remote KMIP Server with a TLS handshake. `certificate` and\n`certificate_authority` determine the certs which will be used to initiate the TLS handshake with `server`.\n\n`validate` is enabled by default. When enabled, system will test connection to `server` making sure\nit's reachable.\n\n`manage_zfs_keys`/`manage_sed_disks` when enabled will sync keys from local database to remote KMIP server.\nWhen disabled, if there are any keys left to be retrieved from the KMIP server,\nit will sync them back to local database.\n\n`enabled` if true, cannot be set to disabled if there are existing keys pending to be synced. However users\ncan still perform this action by enabling `force_clear`.\n\n`change_server` is a boolean field which allows users to migrate data between two KMIP servers. System\nwill first migrate keys from old KMIP server to local database and then migrate the keys from local database\nto new KMIP server. If it is unable to retrieve all the keys from old server, this will fail. Users can bypass\nthis by enabling `force_clear`.\n\n`force_clear` is a boolean option which when enabled will in this case remove all\npending keys to be synced from database. It should be used with extreme caution as users may end up with\nnot having ZFS dataset or SED disks keys leaving them locked forever. It is disabled by default.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/kmip_update_0"
              }
            }
          }
        }
      }
    },
    "/kmip/clear_sync_pending_keys": {
      "get": {
        "tags": [
          "kmip"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Clear all keys which are pending to be synced between KMIP server and TN database.\n\nFor ZFS/SED keys, we remove the UID from local database with which we are able to retrieve ZFS/SED keys.\nIt should be used with caution."
      }
    },
    "/kmip/kmip_sync_pending": {
      "get": {
        "tags": [
          "kmip"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns true or false based on if there are keys which are to be synced from local database to remote KMIP\nserver or vice versa."
      }
    },
    "/kmip/sync_keys": {
      "get": {
        "tags": [
          "kmip"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Sync ZFS/SED keys between KMIP Server and TN database."
      }
    },
    "/ldap": {
      "get": {
        "tags": [
          "ldap"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "ldap"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "`hostname` list of ip addresses or hostnames of LDAP servers with\nwhich to communicate in order of preference. Failover only occurs\nif the current LDAP server is unresponsive.\n\n`basedn` specifies the default base DN to use when performing ldap\noperations. The base must be specified as a Distinguished Name in LDAP\nformat.\n\n`binddn` specifies the default bind DN to use when performing ldap\noperations. The bind DN must be specified as a Distinguished Name in\nLDAP format.\n\n`anonbind` use anonymous authentication.\n\n`ssl` establish SSL/TLS-protected connections to the LDAP server(s).\nGSSAPI signing is disabled on SSL/TLS-protected connections if\nkerberos authentication is used.\n\n`certificate` LDAPs client certificate to be used for certificate-\nbased authentication.\n\n`validate_certificates` specifies whether to perform checks on server\ncertificates in a TLS session. If enabled, TLS_REQCERT demand is set.\nThe server certificate is requested. If no certificate is provided or\nif a bad certificate is provided, the session is immediately terminated.\nIf disabled, TLS_REQCERT allow is set. The server certificate is\nrequested, but all errors are ignored.\n\n`kerberos_realm` in which the server is located. This parameter is\nonly required for SASL GSSAPI authentication to the remote LDAP server.\n\n`kerberos_principal` kerberos principal to use for SASL GSSAPI\nauthentication to the remote server. If `kerberos_realm` is specified\nwithout a keytab, then the `binddn` and `bindpw` are used to\nperform to obtain the ticket necessary for GSSAPI authentication.\n\n`timeout` specifies  a  timeout  (in  seconds) after which calls to\nsynchronous LDAP APIs will abort if no response is received.\n\n`dns_timeout` specifies the timeout (in seconds) after which the\npoll(2)/select(2) following a connect(2) returns in case of no activity\nfor openldap. For nslcd this specifies the time limit (in seconds) to\nuse when connecting to the directory server. This directly impacts the\nlength of time that the LDAP service tries before failing over to\na secondary LDAP URI.\n\n`has_samba_schema` determines whether to configure samba to use the\nldapsam passdb backend to provide SMB access to LDAP users. This feature\nrequires the presence of Samba LDAP schema extensions on the remote\nLDAP server.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ldap_update_0"
              }
            }
          }
        }
      }
    },
    "/ldap/get_state": {
      "get": {
        "tags": [
          "ldap"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Wrapper function for 'directoryservices.get_state'. Returns only the state of the\nLDAP service."
      }
    },
    "/ldap/schema_choices": {
      "get": {
        "tags": [
          "ldap"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns list of available LDAP schema choices."
      }
    },
    "/ldap/ssl_choices": {
      "get": {
        "tags": [
          "ldap"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns list of SSL choices."
      }
    },
    "/lldp": {
      "get": {
        "tags": [
          "lldp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "lldp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update LLDP Service Configuration.\n\n`country` is a two letter ISO 3166 country code required for LLDP location support.\n\n`location` is an optional attribute specifying the physical location of the host.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/lldp_update_0"
              }
            }
          }
        }
      }
    },
    "/lldp/country_choices": {
      "get": {
        "tags": [
          "lldp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns country choices for LLDP."
      }
    },
    "/mail": {
      "get": {
        "tags": [
          "mail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "mail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update Mail Service Configuration.\n\n`fromemail` is used as a sending address which the mail server will use for sending emails.\n\n`outgoingserver` is the hostname or IP address of SMTP server used for sending an email.\n\n`security` is type of encryption desired.\n\n`smtp` is a boolean value which when set indicates that SMTP authentication has been enabled and `user`/`pass`\nare required attributes now.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/mail_update_0"
              }
            }
          }
        }
      }
    },
    "/mail/send": {
      "post": {
        "tags": [
          "mail"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Sends mail using configured mail settings.\n\n`text` will be formatted to HTML using Markdown and rendered using default E-Mail template.\nYou can put your own HTML using `html`. If `html` is null, no HTML MIME part will be added to E-Mail.\n\nIf `attachments` is true, a list compromised of the following dict is required\nvia HTTP upload:\n  - headers(list)\n    - name(str)\n    - value(str)\n    - params(dict)\n  - content (str)\n\n[\n {\n  \"headers\": [\n   {\n    \"name\": \"Content-Transfer-Encoding\",\n    \"value\": \"base64\"\n   },\n   {\n    \"name\": \"Content-Type\",\n    \"value\": \"application/octet-stream\",\n    \"params\": {\n     \"name\": \"test.txt\"\n    }\n   }\n  ],\n  \"content\": \"dGVzdAo=\"\n }\n]\n\nA file can be uploaded to this end point. This end point is special, please refer to Jobs section in Websocket API documentation for details.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/mail_send"
              }
            }
          }
        }
      }
    },
    "/multipath": {
      "get": {
        "tags": [
          "multipath"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Get multipaths and their consumers.\n\n"
      }
    },
    "/multipath/id/{id}": {
      "get": {
        "tags": [
          "multipath"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ],
        "description": "Get multipaths and their consumers.\n\n"
      }
    },
    "/multipath/get_instance": {
      "get": {
        "tags": [
          "multipath"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/network/configuration": {
      "get": {
        "tags": [
          "network.configuration"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "network.configuration"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update Network Configuration Service configuration.\n\n`ipv4gateway` if set is used instead of the default gateway provided by DHCP.\n\n`nameserver1` is primary DNS server.\n\n`nameserver2` is secondary DNS server.\n\n`nameserver3` is tertiary DNS server.\n\n`httpproxy` attribute must be provided if a proxy is to be used for network operations.\n\n`netwait_enabled` is a boolean attribute which when set indicates that network services will not start at\nboot unless they are able to ping the addresses listed in `netwait_ip` list.\n\n`service_announcement` determines the broadcast protocols that will be used to advertise the server.\n`netbios` enables the NetBIOS name server (NBNS), which starts concurrently with the SMB service. SMB clients\nwill only perform NBNS lookups if SMB1 is enabled. NBNS may be required for legacy SMB clients.\n`mdns` enables multicast DNS service announcements for enabled services. `wsd` enables Web Service\nDiscovery support.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/network_configuration_update_0"
              }
            }
          }
        }
      }
    },
    "/network/general/summary": {
      "get": {
        "tags": [
          "network.general"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Retrieve general information for current Network.\n\nReturns a dictionary. For example:\n\n"
      }
    },
    "/nfs": {
      "get": {
        "tags": [
          "nfs"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "nfs"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update NFS Service Configuration.\n\n`servers` represents number of servers to create.\n\nWhen `allow_nonroot` is set, it allows non-root mount requests to be served.\n\n`bindip` is a list of IP's on which NFS will listen for requests. When it is unset/empty, NFS listens on\nall available addresses.\n\n`v4` when set means that we switch from NFSv3 to NFSv4.\n\n`v4_v3owner` when set means that system will use NFSv3 ownership model for NFSv4.\n\n`v4_krb` will force NFS shares to fail if the Kerberos ticket is unavailable.\n\n`v4_domain` overrides the default DNS domain name for NFSv4.\n\n`mountd_port` specifies the port mountd(8) binds to.\n\n`rpcstatd_port` specifies the port rpc.statd(8) binds to.\n\n`rpclockd_port` specifies the port rpclockd_port(8) binds to.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/nfs_update_0"
              }
            }
          }
        }
      }
    },
    "/nfs/bindip_choices": {
      "get": {
        "tags": [
          "nfs"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns ip choices for NFS service to use"
      }
    },
    "/nis": {
      "get": {
        "tags": [
          "nis"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "nis"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update NIS Service Configuration.\n\n`domain` is the name of NIS domain.\n\n`servers` is a list of hostnames/IP addresses.\n\n`secure_mode` when enabled sets ypbind(8) to refuse binding to any NIS server not running as root on a\nTCP port over 1024.\n\n`manycast` when enabled sets ypbind(8) to bind to the server that responds the fastest.\n\n`enable` enables and starts the NIS service. The NIS service is disabled when this\nvalue is changed to False.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/nis_update_0"
              }
            }
          }
        }
      }
    },
    "/nis/get_state": {
      "get": {
        "tags": [
          "nis"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Wrapper function for 'directoryservices.get_state'. Returns only the state of the\nNIS service."
      }
    },
    "/openvpn/client": {
      "get": {
        "tags": [
          "openvpn.client"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "openvpn.client"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update OpenVPN Client configuration.\n\n`remote` can be a valid ip address / domain which openvpn will try to connect to.\n\n`nobind` must be enabled if OpenVPN client / server are to run concurrently.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/openvpn_client_update_0"
              }
            }
          }
        }
      }
    },
    "/openvpn/client/authentication_algorithm_choices": {
      "get": {
        "tags": [
          "openvpn.client"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns a dictionary of valid authentication algorithms which can be used with OpenVPN server."
      }
    },
    "/openvpn/client/cipher_choices": {
      "get": {
        "tags": [
          "openvpn.client"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns a dictionary of valid ciphers which can be used with OpenVPN server."
      }
    },
    "/openvpn/server": {
      "get": {
        "tags": [
          "openvpn.server"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "openvpn.server"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update OpenVPN Server configuration.\n\nWhen `tls_crypt_auth_enabled` is enabled and `tls_crypt_auth` not provided, a static key is automatically\ngenerated to be used with OpenVPN server.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/openvpn_server_update_0"
              }
            }
          }
        }
      }
    },
    "/openvpn/server/authentication_algorithm_choices": {
      "get": {
        "tags": [
          "openvpn.server"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns a dictionary of valid authentication algorithms which can be used with OpenVPN server."
      }
    },
    "/openvpn/server/cipher_choices": {
      "get": {
        "tags": [
          "openvpn.server"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns a dictionary of valid ciphers which can be used with OpenVPN server."
      }
    },
    "/openvpn/server/client_configuration_generation": {
      "post": {
        "tags": [
          "openvpn.server"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns a configuration for OpenVPN client which can be used with any client to connect to FN/TN OpenVPN\nserver.\n\n`client_certificate_id` should be a valid certificate issued for use with OpenVPN client service.\n\n`server_address` if specified auto-fills the remote directive in the OpenVPN configuration enabling the end\nuser to use the file without making any edits to connect to OpenVPN server.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/openvpn_server_client_configuration_generation"
              }
            }
          }
        }
      }
    },
    "/openvpn/server/renew_static_key": {
      "get": {
        "tags": [
          "openvpn.server"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Reset OpenVPN server's TLS static key which will be used to encrypt/authenticate control channel packets."
      }
    },
    "/plugin": {
      "get": {
        "tags": [
          "plugin"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Query installed plugins with `query-filters` and `query-options`."
      },
      "post": {
        "tags": [
          "plugin"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a Plugin.\n\n`plugin_name` is the name of the plugin specified by the INDEX file in \"plugin_repository\" and it's JSON\nfile.\n\n`jail_name` is the name of the jail that will manage the plugin. Required.\n\n`props` is a list of jail properties that the user manually sets. Plugins should always set the jail\nnetworking capability with DHCP, IP Address, or NAT properties. i.e dhcp=1 / ip4_addr=\"192.168.0.2\" / nat=1\n\n`plugin_repository` is a git URI that fetches data for `plugin_name`.\n\n`branch` is the FreeNAS repository branch to use as the base for the `plugin_repository`. The default is to\nuse the current system version. Example: 11.3-RELEASE.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/plugin_create_0"
              }
            }
          }
        }
      }
    },
    "/plugin/id/{id}": {
      "delete": {
        "tags": [
          "plugin"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Delete plugin `id`."
      },
      "get": {
        "tags": [
          "plugin"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ],
        "description": "Query installed plugins with `query-filters` and `query-options`."
      },
      "put": {
        "tags": [
          "plugin"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Update plugin `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/plugin_update_1"
              }
            }
          }
        }
      }
    },
    "/plugin/available": {
      "post": {
        "tags": [
          "plugin"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "List available plugins which can be fetched for `plugin_repository`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/plugin_available_0"
              }
            }
          }
        }
      }
    },
    "/plugin/branches_choices": {
      "post": {
        "tags": [
          "plugin"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/plugin_branches_choices_0"
              }
            }
          }
        }
      }
    },
    "/plugin/defaults": {
      "post": {
        "tags": [
          "plugin"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Retrieve default properties specified for `plugin` in the plugin's manifest.\n\nWhen `refresh` is specified, `plugin_repository` is updated before retrieving plugin's default properties.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/plugin_defaults_0"
              }
            }
          }
        }
      }
    },
    "/plugin/get_instance": {
      "get": {
        "tags": [
          "plugin"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/plugin/official_repositories": {
      "get": {
        "tags": [
          "plugin"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "List officially supported plugin repositories."
      }
    },
    "/plugin/retrieve_versions_for_repos": {
      "get": {
        "tags": [
          "plugin"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      }
    },
    "/pool": {
      "get": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a new ZFS Pool.\n\n`topology` is a object which requires at least one `data` entry.\nAll of `data` entries (vdevs) require to be of the same type.\n\n`deduplication` when set to ON or VERIFY makes sure that no block of data is duplicated in the pool. When\nVERIFY is specified, if two blocks have similar signatures, byte to byte comparison is performed to ensure that\nthe blocks are identical. This should be used in special circumstances as it carries a significant overhead.\n\n`encryption` when enabled will create an ZFS encrypted root dataset for `name` pool.\n\n`encryption_options` specifies configuration for encryption of root dataset for `name` pool.\n`encryption_options.passphrase` must be specified if encryption for root dataset is desired with a passphrase\nas a key.\nOtherwise a hex encoded key can be specified by providing `encryption_options.key`.\n`encryption_options.generate_key` when enabled automatically generates the key to be used\nfor dataset encryption.\n\nIt should be noted that keys are stored by the system for automatic locking/unlocking\non import/export of encrypted datasets. If that is not desired, dataset should be created\nwith a passphrase as a key.\n\nExample of `topology`:\n\n    {\n        \"data\": [\n            {\"type\": \"RAIDZ1\", \"disks\": [\"da1\", \"da2\", \"da3\"]}\n        ],\n        \"cache\": [\n            {\"type\": \"STRIPE\", \"disks\": [\"da4\"]}\n        ],\n        \"log\": [\n            {\"type\": \"STRIPE\", \"disks\": [\"da5\"]}\n        ],\n        \"spares\": [\"da6\"]\n    }\n\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_create_0"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}": {
      "get": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update pool of `id`, adding the new topology.\n\nThe `type` of `data` must be the same of existing vdevs.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_update_1"
              }
            }
          }
        }
      }
    },
    "/pool/attach": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "For TrueNAS Core/Enterprise platform, if the `oid` pool is passphrase GELI encrypted, `passphrase`\nmust be specified for this operation to succeed.\n\n`target_vdev` is the GUID of the vdev where the disk needs to be attached. In case of STRIPED vdev, this\nis the STRIPED disk GUID which will be converted to mirror. If `target_vdev` is mirror, it will be converted\ninto a n-way mirror.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_attach"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/attachments": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Return a list of services dependent of this pool.\n\nResponsible for telling the user whether there is a related\nshare, asking for confirmation.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_attachments"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/detach": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Detach a disk from pool of id `id`.\n\n`label` is the vdev guid or device name.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_detach_1"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/download_encryption_key": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Download encryption key for a given pool `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_download_encryption_key_1"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/expand": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Expand pool to fit all available disk space.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_expand_1"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/export": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Export pool of `id`.\n\n`cascade` will delete all attachments of the given pool (`pool.attachments`).\n`restart_services` will restart services that have open files on given pool.\n`destroy` will also PERMANENTLY destroy the pool/data.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_export_1"
              }
            }
          }
        }
      }
    },
    "/pool/filesystem_choices": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns all available datasets, except system datasets.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_filesystem_choices_0"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/get_disks": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id",
              "default": null,
              "nullable": true
            }
          }
        ],
        "description": "Get all disks in use by pools.\nIf `id` is provided only the disks from the given pool `id` will be returned.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_get_disks"
              }
            }
          }
        }
      }
    },
    "/pool/get_instance": {
      "get": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/pool/import_disk": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Import a disk, by copying its content to a pool.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_import_disk"
              }
            }
          }
        }
      }
    },
    "/pool/import_disk_autodetect_fs_type": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Autodetect filesystem type for `pool.import_disk`.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_import_disk_autodetect_fs_type_0"
              }
            }
          }
        }
      }
    },
    "/pool/import_disk_msdosfs_locales": {
      "get": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get a list of locales for msdosfs type to be used in `pool.import_disk`."
      }
    },
    "/pool/import_find": {
      "get": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns a job id which can be used to retrieve a list of pools available for\nimport with the following details as a result of the job:\nname, guid, status, hostname."
      }
    },
    "/pool/import_pool": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Import a pool found with `pool.import_find`.\n\nIf a `name` is specified the pool will be imported using that new name.\n\n`passphrase` is required while importing an encrypted pool. In that case this method needs to\nbe called using /_upload/ endpoint with the encryption key.\n\nIf `enable_attachments` is set to true, attachments that were disabled during pool export will be\nre-enabled.\n\nErrors:\n    ENOENT - Pool not found\n\n\n\nA file can be uploaded to this end point. This end point is special, please refer to Jobs section in Websocket API documentation for details.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_import_pool_0"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/is_upgraded": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Returns whether or not the pool of `id` is on the latest version and with all feature\nflags enabled.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_is_upgraded"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/lock": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Lock encrypted pool `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_lock_1"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/offline": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Offline a disk from pool of id `id`.\n\n`label` is the vdev guid or device name.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_offline_1"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/online": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Online a disk from pool of id `id`.\n\n`label` is the vdev guid or device name.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_online_1"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/passphrase": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Create/Change/Remove passphrase for an encrypted pool.\n\nSetting passphrase to null will remove the passphrase.\n`admin_password` is required when changing or removing passphrase.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_passphrase_1"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/processes": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Returns a list of running processes using this pool.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_processes"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/recoverykey_rm": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Remove recovery key for encrypted pool `id`.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_recoverykey_rm_1"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/rekey": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Rekey encrypted pool `id`.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_rekey_1"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/remove": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Remove a disk from pool of id `id`.\n\n`label` is the vdev guid or device name.\n\nError codes:\n\n    EZFS_NOSPC(2032): out of space to remove a device\n    EZFS_NODEVICE(2017): no such device in pool\n    EZFS_NOREPLICAS(2019): no valid replicas\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_remove_1"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/replace": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Replace a disk on a pool.\n\n`label` is the ZFS guid or a device name\n`disk` is the identifier of a disk\n`passphrase` is only valid for TrueNAS Core/Enterprise platform where pool is GELI encrypted\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_replace_1"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/scrub": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Performs a scrub action to pool of `id`.\n\n`action` can be either of \"START\", \"STOP\" or \"PAUSE\".\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_scrub_1"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/unlock": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Unlock encrypted pool `id`.\n\n`passphrase` is required of a recovery key is not provided.\n\nIf `recoverykey` is true this method expects the recovery key file to be uploaded using\nthe /_upload/ endpoint.\n\n`services_restart` is a list of services to be restarted when the pool gets unlocked.\nSaid list be be retrieve using `pool.unlock_services_restart_choices`.\n\n\n\nA file can be uploaded to this end point. This end point is special, please refer to Jobs section in Websocket API documentation for details.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_unlock_1"
              }
            }
          }
        }
      }
    },
    "/pool/unlock_services_restart_choices": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get a mapping of services identifiers and labels that can be restart\non volume unlock.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_unlock_services_restart_choices_0"
              }
            }
          }
        }
      }
    },
    "/pool/id/{id}/upgrade": {
      "post": {
        "tags": [
          "pool"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Upgrade pool of `id` to latest version with all feature flags.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_upgrade"
              }
            }
          }
        }
      }
    },
    "/pool/dataset": {
      "get": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Query Pool Datasets with `query-filters` and `query-options`.\n\nWe provide two ways to retrieve datasets. The first is a flat structure (default), where\nall datasets in the system are returned as separate objects which contain all data\nthere is for their children. This retrieval type is slightly slower because of duplicates in each object.\nThe second type is hierarchical, where only top level datasets are returned in the list. They contain all the\nchildren in the `children` key. This retrieval type is slightly faster.\nThese options are controlled by the `query-options.extra.flat` attribute (default true)."
      },
      "post": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Creates a dataset/zvol.\n\n`volsize` is required for type=VOLUME and is supposed to be a multiple of the block size.\n`sparse` and `volblocksize` are only used for type=VOLUME.\n\n`encryption` when enabled will create an ZFS encrypted root dataset for `name` pool.\nThere are 2 cases where ZFS encryption is not allowed for a dataset:\n1) Pool in question is GELI encrypted.\n2) If the parent dataset is encrypted with a passphrase and `name` is being created\n   with a key for encrypting the dataset.\n\n`encryption_options` specifies configuration for encryption of dataset for `name` pool.\n`encryption_options.passphrase` must be specified if encryption for dataset is desired with a passphrase\nas a key.\nOtherwise a hex encoded key can be specified by providing `encryption_options.key`.\n`encryption_options.generate_key` when enabled automatically generates the key to be used\nfor dataset encryption.\n\nIt should be noted that keys are stored by the system for automatic locking/unlocking\non import/export of encrypted datasets. If that is not desired, dataset should be created\nwith a passphrase as a key.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_create_0"
              }
            }
          }
        }
      }
    },
    "/pool/dataset/id/{id}": {
      "delete": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Delete dataset/zvol `id`.\n\n`recursive` will also delete/destroy all children datasets.\n`force` will force delete busy datasets.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_delete_1"
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ],
        "description": "Query Pool Datasets with `query-filters` and `query-options`.\n\nWe provide two ways to retrieve datasets. The first is a flat structure (default), where\nall datasets in the system are returned as separate objects which contain all data\nthere is for their children. This retrieval type is slightly slower because of duplicates in each object.\nThe second type is hierarchical, where only top level datasets are returned in the list. They contain all the\nchildren in the `children` key. This retrieval type is slightly faster.\nThese options are controlled by the `query-options.extra.flat` attribute (default true)."
      },
      "put": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Updates a dataset/zvol `id`.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_update_1"
              }
            }
          }
        }
      }
    },
    "/pool/dataset/id/{id}/attachments": {
      "post": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Return a list of services dependent of this dataset.\n\nResponsible for telling the user whether there is a related\nshare, asking for confirmation.\n\nExample return value:\n[\n  {\n    \"type\": \"NFS Share\",\n    \"service\": \"nfs\",\n    \"attachments\": [\"/mnt/tank/work\"]\n  }\n]",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_attachments"
              }
            }
          }
        }
      }
    },
    "/pool/dataset/change_key": {
      "post": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Change encryption properties for `id` encrypted dataset.\n\nChanging dataset encryption to use passphrase instead of a key is not allowed if:\n\n1) It has encrypted roots as children which are encrypted with a key\n2) If it is a root dataset where the system dataset is located\n\nA file can be uploaded to this end point. This end point is special, please refer to Jobs section in Websocket API documentation for details.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_change_key"
              }
            }
          }
        }
      }
    },
    "/pool/dataset/encryption_algorithm_choices": {
      "get": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Retrieve encryption algorithms supported for ZFS dataset encryption."
      }
    },
    "/pool/dataset/encryption_summary": {
      "post": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Retrieve summary of all encrypted roots under `id`.\n\nKeys/passphrase can be supplied to check if the keys are valid.\n\nIt should be noted that there are 2 keys which show if a recursive unlock operation is\ndone for `id`, which dataset will be unlocked and if not why it won't be unlocked. The keys\nnamely are \"unlock_successful\" and \"unlock_error\". The former is a boolean value showing if unlock\nwould succeed/fail. The latter is description why it failed if it failed.\n\nIf a dataset is already unlocked, it will show up as true for \"unlock_successful\" regardless of what\nkey user provided as the unlock keys in the output are to reflect what a real unlock operation would\nbehave. If user is interested in seeing if a provided key is valid or not, then the key to look out for\nin the output is \"valid_key\" which based on what system has in database or if a user provided one, validates\nthe key and sets a boolean value for the dataset.\n\nExample output:\n[\n    {\n        \"name\": \"vol\",\n        \"key_format\": \"PASSPHRASE\",\n        \"key_present_in_database\": false,\n        \"valid_key\": true,\n        \"locked\": true,\n        \"unlock_error\": null,\n        \"unlock_successful\": true\n    },\n    {\n        \"name\": \"vol/c1/d1\",\n        \"key_format\": \"PASSPHRASE\",\n        \"key_present_in_database\": false,\n        \"valid_key\": false,\n        \"locked\": true,\n        \"unlock_error\": \"Provided key is invalid\",\n        \"unlock_successful\": false\n    },\n    {\n        \"name\": \"vol/c\",\n        \"key_format\": \"PASSPHRASE\",\n        \"key_present_in_database\": false,\n        \"valid_key\": false,\n        \"locked\": true,\n        \"unlock_error\": \"Key not provided\",\n        \"unlock_successful\": false\n    },\n    {\n        \"name\": \"vol/c/d2\",\n        \"key_format\": \"PASSPHRASE\",\n        \"key_present_in_database\": false,\n        \"valid_key\": false,\n        \"locked\": true,\n        \"unlock_error\": \"Child cannot be unlocked when parent \"vol/c\" is locked and provided key is invalid\",\n        \"unlock_successful\": false\n    }\n]\n\nA file can be uploaded to this end point. This end point is special, please refer to Jobs section in Websocket API documentation for details.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_encryption_summary"
              }
            }
          }
        }
      }
    },
    "/pool/dataset/get_instance": {
      "get": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/pool/dataset/id/{id}/get_quota": {
      "post": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "ds",
              "type": "string"
            }
          }
        ],
        "description": "Return a list of the specified `quota_type` of  quotas on the ZFS dataset `ds`.\nSupport `query-filters` and `query-options`. used_bytes and used_percentage\nmay not instantly update as space is used.\n\nWhen quota_type is not DATASET, each quota entry has these fields:\n\n`id` - the uid or gid to which the quota applies.\n\n`name` - the user or group name to which the quota applies. Value is\nnull if the id in the quota cannot be resolved to a user or group. This\nindicates that the user or group does not exist on the server.\n\n`quota` - the quota size in bytes.\n\n`used_bytes` - the amount of bytes the user has written to the dataset.\nA value of zero means unlimited.\n\n`used_percentage` - the percentage of the user or group quota consumed.\n\n`obj_quota` - the number of objects that may be owned by `id`.\nA value of zero means unlimited.\n\n'obj_used` - the nubmer of objects currently owned by `id`.\n\n`obj_used_percent` - the percentage of the `obj_quota` currently used.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_get_quota"
              }
            }
          }
        }
      }
    },
    "/pool/dataset/inherit_parent_encryption_properties": {
      "post": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Allows inheriting parent's encryption root discarding its current encryption settings. This\ncan only be done where `id` has an encrypted parent and `id` itself is an encryption root.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_inherit_parent_encryption_properties_0"
              }
            }
          }
        }
      }
    },
    "/pool/dataset/lock": {
      "post": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Locks `id` dataset. It will unmount the dataset and its children before locking.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_lock"
              }
            }
          }
        }
      }
    },
    "/pool/dataset/id/{id}/permission": {
      "post": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Set permissions for a dataset `id`. Permissions may be specified as\neither a posix `mode` or an nfsv4 `acl`. Setting mode will fail if the\ndataset has an existing nfsv4 acl. In this case, the option `stripacl`\nmust be set to `True`.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_permission_1"
              }
            }
          }
        }
      }
    },
    "/pool/dataset/id/{id}/processes": {
      "post": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Return a list of processes using this dataset.\n\nExample return value:\n\n[\n  {\n    \"pid\": 2520,\n    \"name\": \"smbd\",\n    \"service\": \"cifs\"\n  },\n  {\n    \"pid\": 97778,\n    \"name\": \"minio\",\n    \"cmdline\": \"/usr/local/bin/minio -C /usr/local/etc/minio server --address=0.0.0.0:9000 --quiet /mnt/tank/wk\"\n  }\n]",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_processes"
              }
            }
          }
        }
      }
    },
    "/pool/dataset/id/{id}/promote": {
      "post": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Promote the cloned dataset `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_promote"
              }
            }
          }
        }
      }
    },
    "/pool/dataset/recommended_zvol_blocksize": {
      "post": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Helper method to get recommended size for a new zvol (dataset of type VOLUME).\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_recommended_zvol_blocksize_0"
              }
            }
          }
        }
      }
    },
    "/pool/dataset/id/{id}/set_quota": {
      "post": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "ds",
              "type": "string"
            }
          }
        ],
        "description": "There are three over-arching types of quotas for ZFS datasets.\n1) dataset quotas and refquotas. If a DATASET quota type is specified in\nthis API call, then the API acts as a wrapper for `pool.dataset.update`.\n\n2) User and group quotas. These limit the amount of disk space consumed\nby files that are owned by the specified users or groups. If the respective\n\"object quota\" type is specfied, then the quota limits the number of objects\nthat may be owned by the specified user or group.\n\n3) Project quotas. These limit the amount of disk space consumed by files\nthat are owned by the specified project. Project quotas are not yet implemended.\n\nThis API allows users to set multiple quotas simultaneously by submitting a\nlist of quotas. The list may contain all supported quota types.\n\n`ds` the name of the target ZFS dataset.\n\n`quotas` specifies a list of `quota_entry` entries to apply to dataset.\n\n`quota_entry` entries have these required parameters:\n\n`quota_type`: specifies the type of quota to apply to the dataset. Possible\nvalues are USER, USEROBJ, GROUP, GROUPOBJ, and DATASET. USEROBJ and GROUPOBJ\nquotas limit the number of objects consumed by the specified user or group.\n\n`id`: the uid, gid, or name to which the quota applies. If quota_type is\n'DATASET', then `id` must be either `QUOTA` or `REFQUOTA`.\n\n`quota_value`: the quota size in bytes. Setting a value of `0` removes\nthe user or group quota.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_set_quota_1"
              }
            }
          }
        }
      }
    },
    "/pool/dataset/unlock": {
      "post": {
        "tags": [
          "pool.dataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Unlock `id` dataset.\n\nIf `id` dataset is not encrypted an exception will be raised. There is one exception:\nwhen `id` is a root dataset and `unlock_options.recursive` is specified, encryption\nvalidation will not be performed for `id`. This allow unlocking encrypted children the `id` pool.\n\nFor datasets which are encrypted with a passphrase, include the passphrase with\n`unlock_options.datasets`.\n\nUploading a json file which contains encrypted dataset keys can be specified with\n`unlock_options.key_file`. The format is similar to that used for exporting encrypted dataset keys.\n\nA file can be uploaded to this end point. This end point is special, please refer to Jobs section in Websocket API documentation for details.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_unlock"
              }
            }
          }
        }
      }
    },
    "/pool/dataset/userprop": {
      "get": {
        "tags": [
          "pool.dataset.userprop"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Query all user properties for ZFS datasets."
      },
      "post": {
        "tags": [
          "pool.dataset.userprop"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a user property for a given `id` dataset.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_userprop_create_0"
              }
            }
          }
        }
      }
    },
    "/pool/dataset/userprop/id/{id}": {
      "delete": {
        "tags": [
          "pool.dataset.userprop"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Delete user property `dataset_user_prop_delete.name` for `id` dataset.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_userprop_delete_1"
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "pool.dataset.userprop"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ],
        "description": "Query all user properties for ZFS datasets."
      },
      "put": {
        "tags": [
          "pool.dataset.userprop"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Update `dataset_user_prop_update.name` user property for `id` dataset.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_dataset_userprop_update_1"
              }
            }
          }
        }
      }
    },
    "/pool/dataset/userprop/get_instance": {
      "get": {
        "tags": [
          "pool.dataset.userprop"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/pool/resilver": {
      "get": {
        "tags": [
          "pool.resilver"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "pool.resilver"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Configure Pool Resilver Priority.\n\nIf `begin` time is greater than `end` time it means it will rollover the day, e.g.\nbegin = \"19:00\", end = \"05:00\" will increase pool resilver priority from 19:00 of one day\nuntil 05:00 of the next day.\n\n`weekday` follows crontab(5) values 0-7 (0 or 7 is Sun).\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_resilver_update_0"
              }
            }
          }
        }
      }
    },
    "/pool/scrub": {
      "get": {
        "tags": [
          "pool.scrub"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "pool.scrub"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a scrub task for a pool.\n\n`threshold` refers to the minimum amount of time in days has to be passed before\na scrub can run again.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_scrub_create_0"
              }
            }
          }
        }
      }
    },
    "/pool/scrub/id/{id}": {
      "delete": {
        "tags": [
          "pool.scrub"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete scrub task of `id`."
      },
      "get": {
        "tags": [
          "pool.scrub"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "pool.scrub"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update scrub task of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_scrub_update_1"
              }
            }
          }
        }
      }
    },
    "/pool/scrub/get_instance": {
      "get": {
        "tags": [
          "pool.scrub"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/pool/scrub/run": {
      "post": {
        "tags": [
          "pool.scrub"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Initiate a scrub of a pool `name` if last scrub was performed more than `threshold` days before.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_scrub_run"
              }
            }
          }
        }
      }
    },
    "/pool/snapshottask": {
      "get": {
        "tags": [
          "pool.snapshottask"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "pool.snapshottask"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a Periodic Snapshot Task\n\nCreate a Periodic Snapshot Task that will take snapshots of specified `dataset` at specified `schedule`.\nRecursive snapshots can be created if `recursive` flag is enabled. You can `exclude` specific child datasets\nfrom snapshot.\nSnapshots will be automatically destroyed after a certain amount of time, specified by\n`lifetime_value` and `lifetime_unit`.\nSnapshots will be named according to `naming_schema` which is a `strftime`-like template for snapshot name\nand must contain `%Y`, `%m`, `%d`, `%H` and `%M`.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_snapshottask_create_0"
              }
            }
          }
        }
      }
    },
    "/pool/snapshottask/id/{id}": {
      "delete": {
        "tags": [
          "pool.snapshottask"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete a Periodic Snapshot Task with specific `id`\n\n"
      },
      "get": {
        "tags": [
          "pool.snapshottask"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "pool.snapshottask"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update a Periodic Snapshot Task with specific `id`\n\nSee the documentation for `create` method for information on payload contents\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_snapshottask_update_1"
              }
            }
          }
        }
      }
    },
    "/pool/snapshottask/get_instance": {
      "get": {
        "tags": [
          "pool.snapshottask"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/pool/snapshottask/id/{id}/run": {
      "post": {
        "tags": [
          "pool.snapshottask"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Execute a Periodic Snapshot Task of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pool_snapshottask_run"
              }
            }
          }
        }
      }
    },
    "/replication": {
      "get": {
        "tags": [
          "replication"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "replication"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a Replication Task\n\nCreate a Replication Task that will push or pull ZFS snapshots to or from remote host..\n\n* `name` specifies a name for replication task\n* `direction` specifies whether task will `PUSH` or `PULL` snapshots\n* `transport` is a method of snapshots transfer:\n  * `SSH` transfers snapshots via SSH connection. This method is supported everywhere but does not achieve\n    great performance\n    `ssh_credentials` is a required field for this transport (Keychain Credential ID of type `SSH_CREDENTIALS`)\n  * `SSH+NETCAT` uses unencrypted connection for data transfer. This can only be used in trusted networks\n    and requires a port (specified by range from `netcat_active_side_port_min` to `netcat_active_side_port_max`)\n    to be open on `netcat_active_side`\n    `ssh_credentials` is also required for control connection\n  * `LOCAL` replicates to or from localhost\n* `source_datasets` is a non-empty list of datasets to replicate snapshots from\n* `target_dataset` is a dataset to put snapshots into. It must exist on target side\n* `recursive` and `exclude` have the same meaning as for Periodic Snapshot Task\n* `properties` control whether we should send dataset properties along with snapshots\n* `periodic_snapshot_tasks` is a list of periodic snapshot task IDs that are sources of snapshots for this\n  replication task. Only push replication tasks can be bound to periodic snapshot tasks.\n* `naming_schema` is a list of naming schemas for pull replication\n* `also_include_naming_schema` is a list of naming schemas for push replication\n* `auto` allows replication to run automatically on schedule or after bound periodic snapshot task\n* `schedule` is a schedule to run replication task. Only `auto` replication tasks without bound periodic\n  snapshot tasks can have a schedule\n* `restrict_schedule` restricts when replication task with bound periodic snapshot tasks runs. For example,\n  you can have periodic snapshot tasks that run every 15 minutes, but only run replication task every hour.\n* Enabling `only_matching_schedule` will only replicate snapshots that match `schedule` or\n  `restrict_schedule`\n* `allow_from_scratch` will destroy all snapshots on target side and replicate everything from scratch if none\n  of the snapshots on target side matches source snapshots\n* `readonly` controls destination datasets readonly property:\n  * `SET` will set all destination datasets to readonly=on after finishing the replication\n  * `REQUIRE` will require all existing destination datasets to have readonly=on property\n  * `IGNORE` will avoid this kind of behavior\n* `hold_pending_snapshots` will prevent source snapshots from being deleted by retention of replication fails\n  for some reason\n* `retention_policy` specifies how to delete old snapshots on target side:\n  * `SOURCE` deletes snapshots that are absent on source side\n  * `CUSTOM` deletes snapshots that are older than `lifetime_value` and `lifetime_unit`\n  * `NONE` does not delete any snapshots\n* `compression` compresses SSH stream. Available only for SSH transport\n* `speed_limit` limits speed of SSH stream. Available only for SSH transport\n* `dedup`, `large_block`, `embed` and `compressed` are various ZFS stream flag documented in `man zfs send`\n* `retries` specifies number of retries before considering replication failed\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/replication_create_0"
              }
            }
          }
        }
      }
    },
    "/replication/id/{id}": {
      "delete": {
        "tags": [
          "replication"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete a Replication Task with specific `id`\n\n"
      },
      "get": {
        "tags": [
          "replication"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "replication"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update a Replication Task with specific `id`\n\nSee the documentation for `create` method for information on payload contents\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/replication_update_1"
              }
            }
          }
        }
      }
    },
    "/replication/count_eligible_manual_snapshots": {
      "post": {
        "tags": [
          "replication"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Count how many existing snapshots of `dataset` match `naming_schema`.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/replication_count_eligible_manual_snapshots"
              }
            }
          }
        }
      }
    },
    "/replication/create_dataset": {
      "post": {
        "tags": [
          "replication"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Creates dataset on remote side\n\nAccepts `dataset` name, `transport` and SSH credentials ID (for non-local transport)\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/replication_create_dataset"
              }
            }
          }
        }
      }
    },
    "/replication/get_instance": {
      "get": {
        "tags": [
          "replication"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/replication/list_datasets": {
      "post": {
        "tags": [
          "replication"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "List datasets on remote side\n\nAccepts `transport` and SSH credentials ID (for non-local transport)\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/replication_list_datasets"
              }
            }
          }
        }
      }
    },
    "/replication/list_naming_schemas": {
      "get": {
        "tags": [
          "replication"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "List all naming schemas used in periodic snapshot and replication tasks."
      }
    },
    "/replication/id/{id}/restore": {
      "post": {
        "tags": [
          "replication"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Create the opposite of replication task `id` (PULL if it was PUSH and vice versa).",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/replication_restore_1"
              }
            }
          }
        }
      }
    },
    "/replication/id/{id}/run": {
      "post": {
        "tags": [
          "replication"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Run Replication Task of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/replication_run"
              }
            }
          }
        }
      }
    },
    "/replication/target_unmatched_snapshots": {
      "post": {
        "tags": [
          "replication"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Check if target has any snapshots that do not exist on source.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/replication_target_unmatched_snapshots"
              }
            }
          }
        }
      }
    },
    "/reporting": {
      "get": {
        "tags": [
          "reporting"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "reporting"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Configure Reporting Database settings.\n\nIf `cpu_in_percentage` is `true`, collectd reports CPU usage in percentage instead of \"jiffies\".\n\n`graphite` specifies a destination hostname or IP for collectd data sent by the Graphite plugin..\n\n`graphite_separateinstances` corresponds to collectd SeparateInstances option.\n\n`graph_age` specifies the maximum age of stored graphs in months. `graph_points` is the number of points for\neach hourly, daily, weekly, etc. graph. Changing these requires destroying the current reporting database,\nso when these fields are changed, an additional `confirm_rrd_destroy: true` flag must be present.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/reporting_update_0"
              }
            }
          }
        }
      }
    },
    "/reporting/get_data": {
      "post": {
        "tags": [
          "reporting"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get reporting data for given graphs.\n\nList of possible graphs can be retrieved using `reporting.graphs` call.\n\nFor the time period of the graph either `unit` and `page` OR `start` and `end` should be\nused, not both.\n\n`aggregate` will return aggregate available data for each graph (e.g. min, max, mean).\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/reporting_get_data"
              }
            }
          }
        }
      }
    },
    "/reporting/graphs": {
      "get": {
        "tags": [
          "reporting"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      }
    },
    "/route/ipv4gw_reachable": {
      "post": {
        "tags": [
          "route"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get the IPv4 gateway and verify if it is reachable by any interface.\n\nReturns:\n    bool: True if the gateway is reachable or otherwise False.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/route_ipv4gw_reachable_0"
              }
            }
          }
        }
      }
    },
    "/route/system_routes": {
      "get": {
        "tags": [
          "route"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Get current/applied network routes."
      }
    },
    "/rsyncd": {
      "get": {
        "tags": [
          "rsyncd"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "rsyncd"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update Rsyncd Service Configuration.\n\n`auxiliary` attribute can be used to pass on any additional parameters from rsyncd.conf(5).",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/rsyncd_update_0"
              }
            }
          }
        }
      }
    },
    "/rsyncmod": {
      "get": {
        "tags": [
          "rsyncmod"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "rsyncmod"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a Rsyncmod module.\n\n`path` represents the path to a dataset. Path length is limited to 1023 characters maximum as per the limit\nenforced by FreeBSD. It is possible that we reach this max length recursively while transferring data. In that\ncase, the user must ensure the maximum path will not be too long or modify the recursed path to shorter\nthan the limit.\n\n`maxconn` is an integer value representing the maximum number of simultaneous connections. Zero represents\nunlimited.\n\n`hostsallow` is a list of patterns to match hostname/ip address of a connecting client. If list is empty,\nall hosts are allowed.\n\n`hostsdeny` is a list of patterns to match hostname/ip address of a connecting client. If the pattern is\nmatched, access is denied to the client. If no client should be denied, this should be left empty.\n\n`auxiliary` attribute can be used to pass on any additional parameters from rsyncd.conf(5).",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/rsyncmod_create_0"
              }
            }
          }
        }
      }
    },
    "/rsyncmod/id/{id}": {
      "delete": {
        "tags": [
          "rsyncmod"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete Rsyncmod module of `id`."
      },
      "get": {
        "tags": [
          "rsyncmod"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "rsyncmod"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update Rsyncmod module of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/rsyncmod_update_1"
              }
            }
          }
        }
      }
    },
    "/rsyncmod/get_instance": {
      "get": {
        "tags": [
          "rsyncmod"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/rsynctask": {
      "get": {
        "tags": [
          "rsynctask"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "rsynctask"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a Rsync Task.\n\nSee the comment in Rsyncmod about `path` length limits.\n\n`remotehost` is ip address or hostname of the remote system. If username differs on the remote host,\n\"username@remote_host\" format should be used.\n\n`mode` represents different operating mechanisms for Rsync i.e Rsync Module mode / Rsync SSH mode.\n\n`remotemodule` is the name of remote module, this attribute should be specified when `mode` is set to MODULE.\n\n`remotepath` specifies the path on the remote system.\n\n`validate_rpath` is a boolean which when sets validates the existence of the remote path.\n\n`direction` specifies if data should be PULLED or PUSHED from the remote system.\n\n`compress` when set reduces the size of the data which is to be transmitted.\n\n`archive` when set makes rsync run recursively, preserving symlinks, permissions, modification times, group,\nand special files.\n\n`delete` when set deletes files in the destination directory which do not exist in the source directory.\n\n`preserveperm` when set preserves original file permissions.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/rsynctask_create_0"
              }
            }
          }
        }
      }
    },
    "/rsynctask/id/{id}": {
      "delete": {
        "tags": [
          "rsynctask"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete Rsync Task of `id`."
      },
      "get": {
        "tags": [
          "rsynctask"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "rsynctask"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update Rsync Task of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/rsynctask_update_1"
              }
            }
          }
        }
      }
    },
    "/rsynctask/get_instance": {
      "get": {
        "tags": [
          "rsynctask"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/rsynctask/id/{id}/run": {
      "post": {
        "tags": [
          "rsynctask"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Job to run rsync task of `id`.\n\nOutput is saved to job log excerpt as well as syslog.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/rsynctask_run"
              }
            }
          }
        }
      }
    },
    "/s3": {
      "get": {
        "tags": [
          "s3"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "s3"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update S3 Service Configuration.\n\n`access_key` must only contain alphanumeric characters and should be between 5 and 20 characters.\n\n`secret_key` must only contain alphanumeric characters and should be between 8 and 40 characters.\n\n`browser` when set, enables the web user interface for the S3 Service.\n\n`certificate` is a valid certificate id which exists in the system. This is used to enable secure\nS3 connections.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/s3_update_0"
              }
            }
          }
        }
      }
    },
    "/s3/bindip_choices": {
      "get": {
        "tags": [
          "s3"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Return ip choices for S3 service to use."
      }
    },
    "/sensor/query": {
      "get": {
        "tags": [
          "sensor"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      }
    },
    "/service": {
      "get": {
        "tags": [
          "service"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Query all system services with `query-filters` and `query-options`."
      }
    },
    "/service/id/{id}": {
      "get": {
        "tags": [
          "service"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ],
        "description": "Query all system services with `query-filters` and `query-options`."
      },
      "put": {
        "tags": [
          "service"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id_or_name",
              "type": "string"
            }
          }
        ],
        "description": "Update service entry of `id_or_name`.\n\nCurrently it only accepts `enable` option which means whether the\nservice should start on boot.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/service_update_1"
              }
            }
          }
        }
      }
    },
    "/service/get_instance": {
      "get": {
        "tags": [
          "service"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/service/reload": {
      "post": {
        "tags": [
          "service"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Reload the service specified by `service`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/service_reload"
              }
            }
          }
        }
      }
    },
    "/service/restart": {
      "post": {
        "tags": [
          "service"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Restart the service specified by `service`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/service_restart"
              }
            }
          }
        }
      }
    },
    "/service/start": {
      "post": {
        "tags": [
          "service"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Start the service specified by `service`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/service_start"
              }
            }
          }
        }
      }
    },
    "/service/started": {
      "get": {
        "tags": [
          "service"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Test if service specified by `service` has been started."
      }
    },
    "/service/stop": {
      "post": {
        "tags": [
          "service"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Stop the service specified by `service`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/service_stop"
              }
            }
          }
        }
      }
    },
    "/service/terminate_process": {
      "post": {
        "tags": [
          "service"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Terminate process by `pid`.\n\nFirst send `TERM` signal, then, if was not terminated in `timeout` seconds, send `KILL` signal.\n\nReturns `true` is process has been successfully terminated with `TERM` and `false` if we had to use `KILL`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/service_terminate_process"
              }
            }
          }
        }
      }
    },
    "/sharing/afp": {
      "get": {
        "tags": [
          "sharing.afp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "sharing.afp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create AFP share.\n\n`allow`, `deny`, `ro`, and `rw` are lists of users and groups. Groups are designated by\nan @ prefix.\n\n`hostsallow` and `hostsdeny` are lists of hosts and/or networks.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/sharing_afp_create_0"
              }
            }
          }
        }
      }
    },
    "/sharing/afp/id/{id}": {
      "delete": {
        "tags": [
          "sharing.afp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete AFP share `id`."
      },
      "get": {
        "tags": [
          "sharing.afp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "sharing.afp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update AFP share `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/sharing_afp_update_1"
              }
            }
          }
        }
      }
    },
    "/sharing/afp/get_instance": {
      "get": {
        "tags": [
          "sharing.afp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/sharing/nfs": {
      "get": {
        "tags": [
          "sharing.nfs"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "sharing.nfs"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a NFS Share.\n\n`paths` is a list of valid paths which are configured to be shared on this share.\n\n`networks` is a list of authorized networks that are allowed to access the share having format\n\"network/mask\" CIDR notation. If empty, all networks are allowed.\n\n`hosts` is a list of IP's/hostnames which are allowed to access the share. If empty, all IP's/hostnames are\nallowed.\n\n`alldirs` is a boolean value which when set indicates that the client can mount any subdirectories of the\nselected pool or dataset.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/sharing_nfs_create_0"
              }
            }
          }
        }
      }
    },
    "/sharing/nfs/id/{id}": {
      "delete": {
        "tags": [
          "sharing.nfs"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete NFS Share of `id`."
      },
      "get": {
        "tags": [
          "sharing.nfs"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "sharing.nfs"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update NFS Share of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/sharing_nfs_update_1"
              }
            }
          }
        }
      }
    },
    "/sharing/nfs/get_instance": {
      "get": {
        "tags": [
          "sharing.nfs"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/sharing/smb": {
      "get": {
        "tags": [
          "sharing.smb"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "sharing.smb"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a SMB Share.\n\n`purpose` applies common configuration presets depending on intended purpose.\n\n`timemachine` when set, enables Time Machine backups for this share.\n\n`ro` when enabled, prohibits write access to the share.\n\n`guestok` when enabled, allows access to this share without a password.\n\n`hostsallow` is a list of hostnames / IP addresses which have access to this share.\n\n`hostsdeny` is a list of hostnames / IP addresses which are not allowed access to this share. If a handful\nof hostnames are to be only allowed access, `hostsdeny` can be passed \"ALL\" which means that it will deny\naccess to ALL hostnames except for the ones which have been listed in `hostsallow`.\n\n`acl` enables support for storing the SMB Security Descriptor as a Filesystem ACL.\n\n`streams` enables support for storing alternate datastreams as filesystem extended attributes.\n\n`fsrvp` enables support for the filesystem remote VSS protocol. This allows clients to create\nZFS snapshots through RPC.\n\n`shadowcopy` enables support for the volume shadow copy service.\n\n`auxsmbconf` is a string of additional smb4.conf parameters not covered by the system's API.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/sharing_smb_create_0"
              }
            }
          }
        }
      }
    },
    "/sharing/smb/id/{id}": {
      "delete": {
        "tags": [
          "sharing.smb"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete SMB Share of `id`. This will forcibly disconnect SMB clients\nthat are accessing the share."
      },
      "get": {
        "tags": [
          "sharing.smb"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "sharing.smb"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update SMB Share of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/sharing_smb_update_1"
              }
            }
          }
        }
      }
    },
    "/sharing/smb/get_instance": {
      "get": {
        "tags": [
          "sharing.smb"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/sharing/smb/presets": {
      "get": {
        "tags": [
          "sharing.smb"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Retrieve pre-defined configuration sets for specific use-cases. These parameter\ncombinations are often non-obvious, but beneficial in these scenarios."
      }
    },
    "/sharing/webdav": {
      "get": {
        "tags": [
          "sharing.webdav"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "sharing.webdav"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a Webdav Share.\n\n`ro` when enabled prohibits users from writing to this share.\n\n`perm` when enabled automatically recursively changes the ownership of this share to\nwebdav ( user and group both ).",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/sharing_webdav_create_0"
              }
            }
          }
        }
      }
    },
    "/sharing/webdav/id/{id}": {
      "delete": {
        "tags": [
          "sharing.webdav"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update Webdav Share of `id`."
      },
      "get": {
        "tags": [
          "sharing.webdav"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "sharing.webdav"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update Webdav Share of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/sharing_webdav_update_1"
              }
            }
          }
        }
      }
    },
    "/sharing/webdav/get_instance": {
      "get": {
        "tags": [
          "sharing.webdav"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/smart": {
      "get": {
        "tags": [
          "smart"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "smart"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update SMART Service Configuration.\n\n`interval` is an integer value in minutes which defines how often smartd activates to check if any tests\nare configured to run.\n\n`critical`, `informational` and `difference` are integer values on which alerts for SMART are configured if\nthe disks temperature crosses the assigned threshold for each respective attribute. They default to 0 which\nindicates they are disabled.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/smart_update_0"
              }
            }
          }
        }
      }
    },
    "/smart/test": {
      "get": {
        "tags": [
          "smart.test"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "smart.test"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a SMART Test Task.\n\n`disks` is a list of valid disks which should be monitored in this task.\n\n`type` is specified to represent the type of SMART test to be executed.\n\n`all_disks` when enabled sets the task to cover all disks in which case `disks` is not required.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/smart_test_create_0"
              }
            }
          }
        }
      }
    },
    "/smart/test/id/{id}": {
      "delete": {
        "tags": [
          "smart.test"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete SMART Test Task of `id`."
      },
      "get": {
        "tags": [
          "smart.test"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "smart.test"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update SMART Test Task of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/smart_test_update_1"
              }
            }
          }
        }
      }
    },
    "/smart/test/get_instance": {
      "get": {
        "tags": [
          "smart.test"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/smart/test/manual_test": {
      "post": {
        "tags": [
          "smart.test"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Run manual SMART tests for `disks`.\n\n`type` indicates what type of SMART test will be ran and must be specified.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/smart_test_manual_test_0"
              }
            }
          }
        }
      }
    },
    "/smart/test/results": {
      "get": {
        "tags": [
          "smart.test"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Get disk(s) S.M.A.R.T. test(s) results.\n\n"
      }
    },
    "/smb": {
      "get": {
        "tags": [
          "smb"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "smb"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update SMB Service Configuration.\n\n`netbiosname` defaults to the original hostname of the system.\n\n`workgroup` and `netbiosname` should have different values.\n\n`enable_smb1` allows legacy SMB clients to connect to the server when enabled.\n\n`localmaster` when set, determines if the system participates in a browser election.\n\n`domain_logons` is used to provide netlogin service for older Windows clients if enabled.\n\n`guest` attribute is specified to select the account to be used for guest access. It defaults to \"nobody\".\n\n`nullpw` when enabled allows the users to authorize access without a password.\n\n`hostlookup` when enabled, allows using hostnames rather then IP addresses in \"hostsallow\"/\"hostsdeny\" fields\nof SMB Shares.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/smb_update_0"
              }
            }
          }
        }
      }
    },
    "/smb/bindip_choices": {
      "get": {
        "tags": [
          "smb"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "List of valid choices for IP addresses to which to bind the SMB service.\nAddresses assigned by DHCP are excluded from the results."
      }
    },
    "/smb/domain_choices": {
      "get": {
        "tags": [
          "smb"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "List of domains visible to winbindd. Returns empty list if winbindd is\nstopped."
      }
    },
    "/smb/get_remote_acl": {
      "post": {
        "tags": [
          "smb"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Retrieves an ACL from a remote SMB server.\n\n`server` IP Address or hostname of the remote server\n\n`share` Share name\n\n`path` path on the remote SMB server. Use \"\" to separate path components\n\n`username` username to use for authentication\n\n`password` password to use for authentication\n\n`use_kerberos` use credentials to get a kerberos ticket for authentication.\nAD only.\n\n`output_format` format for resulting ACL data. Choices are either 'SMB',\nwhich will present the information as a Windows SD or 'LOCAL', which formats\nthe ACL information according local filesystem of the TrueNAS server.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/smb_get_remote_acl_0"
              }
            }
          }
        }
      }
    },
    "/smb/status": {
      "post": {
        "tags": [
          "smb"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns SMB server status (sessions, open files, locks, notifications).\n\n`info_level` type of information requests. Defaults to ALL.\n\n`status_options` additional options to filter query results. Supported\nvalues are as follows: `verbose` gives more verbose status output\n`fast` causes smbstatus to not check if the status data is valid by\nchecking if the processes that the status data refer to all still\nexist. This speeds up execution on busy systems and clusters but\nmight display stale data of processes that died without cleaning up\nproperly. `restrict_user` specifies the limits results to the specified\nuser.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/smb_status"
              }
            }
          }
        }
      }
    },
    "/smb/unixcharset_choices": {
      "get": {
        "tags": [
          "smb"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      }
    },
    "/smb/sharesec": {
      "get": {
        "tags": [
          "smb.sharesec"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Use query-filters to search the SMB share ACLs present on server."
      },
      "post": {
        "tags": [
          "smb.sharesec"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update the ACL on a given SMB share. Will write changes to both\n/var/db/system/samba4/share_info.tdb and the configuration file.\nSince an SMB share will _always_ have an ACL present, there is little\ndistinction between the `create` and `update` methods apart from arguments.\n\n`share_name` - name of SMB share.\n\n`share_acl` a list of ACL entries (dictionaries) with the following keys:\n\n`ae_who_sid` who the ACL entry applies to expressed as a Windows SID\n\n`ae_who_name` who the ACL entry applies to expressed as a name. `ae_who_name` is\na dictionary containing the following keys: `domain` that the user is a member of,\n`name` username in the domain. The domain for local users is the netbios name of\nthe FreeNAS server.\n\n`ae_perm` string representation of the permissions granted to the user or group.\n`FULL` grants read, write, execute, delete, write acl, and change owner.\n`CHANGE` grants read, write, execute, and delete.\n`READ` grants read and execute.\n\n`ae_type` can be ALLOWED or DENIED.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/smb_sharesec_create_0"
              }
            }
          }
        }
      }
    },
    "/smb/sharesec/id/{id}": {
      "delete": {
        "tags": [
          "smb.sharesec"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id_or_name",
              "type": "string"
            }
          }
        ],
        "description": "Replace share ACL for the specified SMB share with the samba default ACL of S-1-1-0/FULL\n(Everyone - Full Control). In this case, access will be fully determined\nby the underlying filesystem ACLs and smb4.conf parameters governing access control\nand permissions.\nShare can be deleted by name or numerical by numerical index."
      },
      "get": {
        "tags": [
          "smb.sharesec"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ],
        "description": "Use query-filters to search the SMB share ACLs present on server."
      },
      "put": {
        "tags": [
          "smb.sharesec"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update the ACL on the share specified by the numerical index `id`. Will write changes\nto both /var/db/system/samba4/share_info.tdb and the configuration file.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/smb_sharesec_update_1"
              }
            }
          }
        }
      }
    },
    "/smb/sharesec/get_instance": {
      "get": {
        "tags": [
          "smb.sharesec"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/smb/sharesec/getacl": {
      "post": {
        "tags": [
          "smb.sharesec"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "View the ACL information for `share_name`. The share ACL is distinct from filesystem\nACLs which can be viewed by calling `filesystem.getacl`. `ae_who_name` will appear\nas `None` if the SMB service is stopped or if winbind is unable  to resolve the SID\nto a name.\n\nIf the `option` `resolve_sids` is set to `False` then the returned ACL will not\ncontain names.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/smb_sharesec_getacl"
              }
            }
          }
        }
      }
    },
    "/smb/sharesec/synchronize_acls": {
      "get": {
        "tags": [
          "smb.sharesec"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Synchronize the share ACL stored in the config database with Samba's running\nconfiguration as reflected in the share_info.tdb file.\n\nThe only situation in which the configuration stored in the database will\noverwrite samba's running configuration is if share_info.tdb is empty. Samba\nfakes a single S-1-1-0:ALLOW/0x0/FULL entry in the absence of an entry for a\nshare in share_info.tdb."
      }
    },
    "/snmp": {
      "get": {
        "tags": [
          "snmp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "snmp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update SNMP Service Configuration.\n\n`v3` when set enables SNMP version 3.\n\n`v3_username`, `v3_authtype`, `v3_password`, `v3_privproto` and `v3_privpassphrase` are only used when `v3`\nis enabled.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/snmp_update_0"
              }
            }
          }
        }
      }
    },
    "/ssh": {
      "get": {
        "tags": [
          "ssh"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "ssh"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update settings of SSH daemon service.\n\nIf `bindiface` is empty it will listen for all available addresses.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ssh_update_0"
              }
            }
          }
        }
      }
    },
    "/ssh/bindiface_choices": {
      "get": {
        "tags": [
          "ssh"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Available choices for the bindiface attribute of SSH service."
      }
    },
    "/staticroute": {
      "get": {
        "tags": [
          "staticroute"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "staticroute"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a Static Route.\n\nAddress families of `gateway` and `destination` should match when creating a static route.\n\n`description` is an optional attribute for any notes regarding the static route.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/staticroute_create_0"
              }
            }
          }
        }
      }
    },
    "/staticroute/id/{id}": {
      "delete": {
        "tags": [
          "staticroute"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete Static Route of `id`."
      },
      "get": {
        "tags": [
          "staticroute"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "staticroute"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update Static Route of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/staticroute_update_1"
              }
            }
          }
        }
      }
    },
    "/staticroute/get_instance": {
      "get": {
        "tags": [
          "staticroute"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/stats/get_data": {
      "post": {
        "tags": [
          "stats"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get data points from rrd files.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/stats_get_data"
              }
            }
          }
        }
      }
    },
    "/stats/get_dataset_info": {
      "post": {
        "tags": [
          "stats"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns info about a given dataset from some source.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/stats_get_dataset_info"
              }
            }
          }
        }
      }
    },
    "/stats/get_sources": {
      "get": {
        "tags": [
          "stats"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns an object with all available sources tried with metric datasets."
      }
    },
    "/support": {
      "get": {
        "tags": [
          "support"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "support"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update Proactive Support settings.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/support_update_0"
              }
            }
          }
        }
      }
    },
    "/support/fetch_categories": {
      "post": {
        "tags": [
          "support"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Fetch all the categories available for `username` using `password`.\nReturns a dict with the category name as a key and id as value.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/support_fetch_categories"
              }
            }
          }
        }
      }
    },
    "/support/fields": {
      "get": {
        "tags": [
          "support"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns list of pairs of field names and field titles for Proactive Support."
      }
    },
    "/support/is_available": {
      "get": {
        "tags": [
          "support"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns whether Proactive Support is available for this product type and current license."
      }
    },
    "/support/is_available_and_enabled": {
      "get": {
        "tags": [
          "support"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns whether Proactive Support is available and enabled."
      }
    },
    "/support/new_ticket": {
      "post": {
        "tags": [
          "support"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Creates a new ticket for support.\nThis is done using the support proxy API.\nFor FreeNAS it will be created on Redmine and for TrueNAS on SupportSuite.\n\nFor FreeNAS `criticality`, `environment`, `phone`, `name` and `email` attributes are not required.\nFor TrueNAS `username`, `password` and `type` attributes are not required.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/support_new_ticket_0"
              }
            }
          }
        }
      }
    },
    "/system/boot_id": {
      "get": {
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns an unique boot identifier.\n\nIt is supposed to be unique every system boot."
      }
    },
    "/system/environment": {
      "get": {
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Return environment in which product is running. Possible values:\n- DEFAULT\n- EC2"
      }
    },
    "/system/feature_enabled": {
      "post": {
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns whether the `feature` is enabled or not",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/system_feature_enabled_0"
              }
            }
          }
        }
      }
    },
    "/system/info": {
      "get": {
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns basic system information."
      }
    },
    "/system/is_freenas": {
      "get": {
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "FreeNAS is now TrueNAS CORE.\n\nDEPRECATED: Use `system.product_type`"
      }
    },
    "/system/license_update": {
      "post": {
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update license file.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/system_license_update_0"
              }
            }
          }
        }
      }
    },
    "/system/product_name": {
      "get": {
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns name of the product we are using."
      }
    },
    "/system/product_type": {
      "get": {
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns the type of the product.\n\nCORE - TrueNAS Core, community version\nENTERPRISE - TrueNAS Enterprise, appliance version\nSCALE - TrueNAS SCALE"
      }
    },
    "/system/ready": {
      "get": {
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns whether the system completed boot and is ready to use"
      }
    },
    "/system/reboot": {
      "post": {
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Reboots the operating system.\n\nEmits an \"added\" event of name \"system\" and id \"reboot\".",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/system_reboot_0"
              }
            }
          }
        }
      }
    },
    "/system/shutdown": {
      "post": {
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Shuts down the operating system.\n\nAn \"added\" event of name \"system\" and id \"shutdown\" is emitted when shutdown is initiated.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/system_shutdown_0"
              }
            }
          }
        }
      }
    },
    "/system/state": {
      "get": {
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns system state:\n\"BOOTING\" - System is booting\n\"READY\" - System completed boot and is ready to use\n\"SHUTTING_DOWN\" - System is shutting down"
      }
    },
    "/system/version": {
      "get": {
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns software version of the system."
      }
    },
    "/system/advanced": {
      "get": {
        "tags": [
          "system.advanced"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "system.advanced"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update System Advanced Service Configuration.\n\n`consolemenu` should be disabled if the menu at console is not desired. It will default to standard login\nin the console if disabled.\n\n`autotune` when enabled executes autotune script which attempts to optimize the system based on the installed\nhardware.\n\nWhen `syslogserver` is defined, logs of `sysloglevel` or above are sent.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/system_advanced_update_0"
              }
            }
          }
        }
      }
    },
    "/system/advanced/sed_global_password": {
      "get": {
        "tags": [
          "system.advanced"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns configured global SED password."
      }
    },
    "/system/advanced/serial_port_choices": {
      "get": {
        "tags": [
          "system.advanced"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get available choices for `serialport`."
      }
    },
    "/system/general": {
      "get": {
        "tags": [
          "system.general"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "system.general"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update System General Service Configuration.\n\n`ui_certificate` is used to enable HTTPS access to the system. If `ui_certificate` is not configured on boot,\nit is automatically created by the system.\n\n`ui_httpsredirect` when set, makes sure that all HTTP requests are converted to HTTPS requests to better\nenhance security.\n\n`ui_address` and `ui_v6address` are a list of valid ipv4/ipv6 addresses respectively which the system will\nlisten on.\n\n`syslogserver` and `sysloglevel` are deprecated fields as of 11.3\nand will be permanently moved to system.advanced.update for 12.0",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/system_general_update_0"
              }
            }
          }
        }
      }
    },
    "/system/general/country_choices": {
      "get": {
        "tags": [
          "system.general"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns country choices."
      }
    },
    "/system/general/kbdmap_choices": {
      "get": {
        "tags": [
          "system.general"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns kbdmap choices."
      }
    },
    "/system/general/language_choices": {
      "get": {
        "tags": [
          "system.general"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns language choices."
      }
    },
    "/system/general/local_url": {
      "get": {
        "tags": [
          "system.general"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns configured local url in the format of protocol://host:port"
      }
    },
    "/system/general/timezone_choices": {
      "get": {
        "tags": [
          "system.general"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns time zone choices."
      }
    },
    "/system/general/ui_address_choices": {
      "get": {
        "tags": [
          "system.general"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns UI ipv4 address choices."
      }
    },
    "/system/general/ui_certificate_choices": {
      "get": {
        "tags": [
          "system.general"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Return choices of certificates which can be used for `ui_certificate`."
      }
    },
    "/system/general/ui_httpsprotocols_choices": {
      "get": {
        "tags": [
          "system.general"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns available HTTPS protocols."
      }
    },
    "/system/general/ui_restart": {
      "get": {
        "tags": [
          "system.general"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Restart HTTP server to use latest UI settings."
      }
    },
    "/system/general/ui_v6address_choices": {
      "get": {
        "tags": [
          "system.general"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns UI ipv6 address choices."
      }
    },
    "/system/ntpserver": {
      "get": {
        "tags": [
          "system.ntpserver"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "system.ntpserver"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Add an NTP Server.\n\n`address` specifies the hostname/IP address of the NTP server.\n\n`burst` when enabled makes sure that if server is reachable, sends a burst of eight packets instead of one.\nThis is designed to improve timekeeping quality with the server command.\n\n`iburst` when enabled speeds up the initial synchronization, taking seconds rather than minutes.\n\n`prefer` marks the specified server as preferred. When all other things are equal, this host is chosen\nfor synchronization acquisition with the server command. It is recommended that they be used for servers with\ntime monitoring hardware.\n\n`minpoll` is minimum polling time in seconds. It must be a power of 2 and less than `maxpoll`.\n\n`maxpoll` is maximum polling time in seconds. It must be a power of 2 and greater than `minpoll`.\n\n`force` when enabled forces the addition of NTP server even if it is currently unreachable.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/system_ntpserver_create_0"
              }
            }
          }
        }
      }
    },
    "/system/ntpserver/id/{id}": {
      "delete": {
        "tags": [
          "system.ntpserver"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete NTP server of `id`."
      },
      "get": {
        "tags": [
          "system.ntpserver"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "system.ntpserver"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update NTP server of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/system_ntpserver_update_1"
              }
            }
          }
        }
      }
    },
    "/system/ntpserver/get_instance": {
      "get": {
        "tags": [
          "system.ntpserver"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/system/ntpserver/test_ntp_server": {
      "get": {
        "tags": [
          "system.ntpserver"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      }
    },
    "/systemdataset": {
      "get": {
        "tags": [
          "systemdataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "systemdataset"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update System Dataset Service Configuration.\n\n`pool` is the name of a valid pool configured in the system which will be used to host the system dataset.\n\n`pool_exclude` can be specified to make sure that we don't place the system dataset on that pool if `pool`\nis not provided.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/systemdataset_update_0"
              }
            }
          }
        }
      }
    },
    "/tftp": {
      "get": {
        "tags": [
          "tftp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "tftp"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update TFTP Service Configuration.\n\n`newfiles` when set enables network devices to send files to the system.\n\n`username` sets the user account which will be used to access `directory`. It should be ensured `username`\nhas access to `directory`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/tftp_update_0"
              }
            }
          }
        }
      }
    },
    "/truecommand": {
      "get": {
        "tags": [
          "truecommand"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "truecommand"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update Truecommand service settings.\n\n`api_key` is a valid API key generated by iX Portal.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/truecommand_update_0"
              }
            }
          }
        }
      }
    },
    "/truenas/accept_eula": {
      "get": {
        "tags": [
          "truenas"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Accept TrueNAS EULA."
      }
    },
    "/truenas/get_chassis_hardware": {
      "get": {
        "tags": [
          "truenas"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns what type of hardware this is, detected from dmidecode.\n\nTRUENAS-X10-HA-D\nTRUENAS-X10-S\nTRUENAS-X20-HA-D\nTRUENAS-X20-S\nTRUENAS-M40-HA\nTRUENAS-M40-S\nTRUENAS-M50-HA\nTRUENAS-M50-S\nTRUENAS-M60-HA\nTRUENAS-M60-S\nTRUENAS-Z20-S\nTRUENAS-Z20-HA-D\nTRUENAS-Z30-HA-D\nTRUENAS-Z30-S\nTRUENAS-Z35-HA-D\nTRUENAS-Z35-S\nTRUENAS-Z50-HA-D\nTRUENAS-Z50-S\n\nNothing in dmidecode but a M, X or Z class machine:\n(Note this means production didn't burn the hardware model\ninto SMBIOS. We can detect this case by looking at the\nmotherboard)\nTRUENAS-M\nTRUENAS-X\nTRUENAS-Z\n\nDetected by the motherboard model:\nTRUENAS-SBB\n\nPretty much anything else with a SM X8 board:\n(X8DTH was popular but there are a few other boards out there)\nTRUENAS-SM\n\nReally NFI about hardware at this point.  TrueNAS on a Dell?\nTRUENAS-UNKNOWN"
      }
    },
    "/truenas/get_customer_information": {
      "get": {
        "tags": [
          "truenas"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns stored customer information."
      }
    },
    "/truenas/get_eula": {
      "get": {
        "tags": [
          "truenas"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns the TrueNAS End-User License Agreement (EULA)."
      }
    },
    "/truenas/is_eula_accepted": {
      "get": {
        "tags": [
          "truenas"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns whether the EULA is accepted or not."
      }
    },
    "/truenas/is_production": {
      "get": {
        "tags": [
          "truenas"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns if system is marked as production."
      }
    },
    "/truenas/set_production": {
      "post": {
        "tags": [
          "truenas"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Sets system production state and optionally sends initial debug.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/truenas_set_production"
              }
            }
          }
        }
      }
    },
    "/truenas/update_customer_information": {
      "post": {
        "tags": [
          "truenas"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Updates customer information.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/truenas_update_customer_information_0"
              }
            }
          }
        }
      }
    },
    "/tunable": {
      "get": {
        "tags": [
          "tunable"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "tunable"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a Tunable.\n\n`var` represents name of the sysctl/loader/rc variable.\n\n`type` should be one of the following:\n1) LOADER     -     Configure `var` for loader(8)\n2) RC         -     Configure `var` for rc(8)\n3) SYSCTL     -     Configure `var` for sysctl(8)",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/tunable_create_0"
              }
            }
          }
        }
      }
    },
    "/tunable/id/{id}": {
      "delete": {
        "tags": [
          "tunable"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete Tunable of `id`."
      },
      "get": {
        "tags": [
          "tunable"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "tunable"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update Tunable of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/tunable_update_1"
              }
            }
          }
        }
      }
    },
    "/tunable/get_instance": {
      "get": {
        "tags": [
          "tunable"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/update/check_available": {
      "post": {
        "tags": [
          "update"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Checks if there is an update available from update server.\n\nstatus:\n  - REBOOT_REQUIRED: an update has already been applied\n  - AVAILABLE: an update is available\n  - UNAVAILABLE: no update available\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/update_check_available_0"
              }
            }
          }
        }
      }
    },
    "/update/download": {
      "get": {
        "tags": [
          "update"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Download updates using selected train."
      }
    },
    "/update/get_auto_download": {
      "get": {
        "tags": [
          "update"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns if update auto-download is enabled."
      }
    },
    "/update/get_pending": {
      "post": {
        "tags": [
          "update"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Gets a list of packages already downloaded and ready to be applied.\nEach entry of the lists consists of type of operation and name of it, e.g.\n\n  {\n    \"operation\": \"upgrade\",\n    \"name\": \"baseos-11.0 -> baseos-11.1\"\n  }",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/update_get_pending_0"
              }
            }
          }
        }
      }
    },
    "/update/get_trains": {
      "get": {
        "tags": [
          "update"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns available trains dict and the currently configured train as well as the\ntrain of currently booted environment."
      }
    },
    "/update/manual": {
      "post": {
        "tags": [
          "update"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Apply manual update of file `path`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/update_manual_0"
              }
            }
          }
        }
      }
    },
    "/update/set_auto_download": {
      "post": {
        "tags": [
          "update"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Sets if update auto-download is enabled.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/update_set_auto_download_0"
              }
            }
          }
        }
      }
    },
    "/update/set_train": {
      "post": {
        "tags": [
          "update"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Set an update train to be used by default in updates.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/update_set_train_0"
              }
            }
          }
        }
      }
    },
    "/update/update": {
      "post": {
        "tags": [
          "update"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Downloads (if not already in cache) and apply an update.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/update_update_0"
              }
            }
          }
        }
      }
    },
    "/ups": {
      "get": {
        "tags": [
          "ups"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "ups"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update UPS Service Configuration.\n\n`emailnotify` when enabled, sends out notifications of different UPS events via email.\n\n`powerdown` when enabled, sets UPS to power off after shutting down the system.\n\n`nocommwarntime` is a value in seconds which makes UPS Service wait the specified seconds before alerting that\nthe Service cannot reach configured UPS.\n\n`shutdowntimer` is a value in seconds which tells the Service to wait specified seconds for the UPS before\ninitiating a shutdown. This only applies when `shutdown` is set to \"BATT\".\n\n`shutdowncmd` is the command which is executed to initiate a shutdown. It defaults to \"poweroff\".\n\n`toemail` is a list of valid email id's on which notification emails are sent.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ups_update_0"
              }
            }
          }
        }
      }
    },
    "/ups/driver_choices": {
      "get": {
        "tags": [
          "ups"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns choices of UPS drivers supported by the system."
      }
    },
    "/ups/port_choices": {
      "get": {
        "tags": [
          "ups"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      }
    },
    "/user": {
      "get": {
        "tags": [
          "user"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Query users with `query-filters` and `query-options`. As a performance optimization, only local users\nwill be queried by default.\n\nUsers from directory services such as NIS, LDAP, or Active Directory will be included in query results\nif the option `{'extra': {'search_dscache': True}}` is specified."
      },
      "post": {
        "tags": [
          "user"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a new user.\n\nIf `uid` is not provided it is automatically filled with the next one available.\n\n`group` is required if `group_create` is false.\n\n`password` is required if `password_disabled` is false.\n\nAvailable choices for `shell` can be retrieved with `user.shell_choices`.\n\n`attributes` is a general-purpose object for storing arbitrary user information.\n\n`smb` specifies whether the user should be allowed access to SMB shares. User\nwilll also automatically be added to the `builtin_users` group.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_create_0"
              }
            }
          }
        }
      }
    },
    "/user/id/{id}": {
      "delete": {
        "tags": [
          "user"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete user `id`.\n\nThe `delete_group` option deletes the user primary group if it is not being used by\nany other user.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_delete_1"
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "user"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ],
        "description": "Query users with `query-filters` and `query-options`. As a performance optimization, only local users\nwill be queried by default.\n\nUsers from directory services such as NIS, LDAP, or Active Directory will be included in query results\nif the option `{'extra': {'search_dscache': True}}` is specified."
      },
      "put": {
        "tags": [
          "user"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update attributes of an existing user.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_update_1"
              }
            }
          }
        }
      }
    },
    "/user/get_instance": {
      "get": {
        "tags": [
          "user"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/user/get_next_uid": {
      "get": {
        "tags": [
          "user"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get the next available/free uid."
      }
    },
    "/user/get_user_obj": {
      "post": {
        "tags": [
          "user"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns dictionary containing information from struct passwd for the user specified by either\nthe username or uid. Bypasses user cache.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_get_user_obj_0"
              }
            }
          }
        }
      }
    },
    "/user/has_root_password": {
      "get": {
        "tags": [
          "user"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Return whether the root user has a valid password set.\n\nThis is used when the system is installed without a password and must be set on\nfirst use/login."
      }
    },
    "/user/id/{id}/pop_attribute": {
      "post": {
        "tags": [
          "user"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Remove user general purpose `attributes` dictionary `key`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_pop_attribute_1"
              }
            }
          }
        }
      }
    },
    "/user/id/{id}/set_attribute": {
      "post": {
        "tags": [
          "user"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Set user general purpose `attributes` dictionary `key` to `value`.\n\ne.g. Setting key=\"foo\" value=\"var\" will result in {\"attributes\": {\"foo\": \"bar\"}}",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_set_attribute"
              }
            }
          }
        }
      }
    },
    "/user/shell_choices": {
      "post": {
        "tags": [
          "user"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Return the available shell choices to be used in `user.create` and `user.update`.\n\nIf `user_id` is provided, shell choices are filtered to ensure the user can access the shell choices provided.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_shell_choices_0"
              }
            }
          }
        }
      }
    },
    "/vm": {
      "get": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a Virtual Machine (VM).\n\n`grubconfig` may either be a path for the grub.cfg file or the actual content\nof the file to be used with GRUB bootloader.\n\n`devices` is a list of virtualized hardware to add to the newly created Virtual Machine.\nFailure to attach a device destroys the VM and any resources allocated by the VM devices.\n\nMaximum of 16 guest virtual CPUs are allowed. By default, every virtual CPU is configured as a\nseparate package. Multiple cores can be configured per CPU by specifying `cores` attributes.\n`vcpus` specifies total number of CPU sockets. `cores` specifies number of cores per socket. `threads`\nspecifies number of threads per core.\n\n`shutdown_timeout` indicates the time in seconds the system waits for the VM to cleanly shutdown. During system\nshutdown, if the VM hasn't exited after a hardware shutdown signal has been sent by the system within\n`shutdown_timeout` seconds, system initiates poweroff for the VM to stop it.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vm_create_0"
              }
            }
          }
        }
      }
    },
    "/vm/id/{id}": {
      "delete": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete a VM.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vm_delete_1"
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update all information of a specific VM.\n\n`devices` is a list of virtualized hardware to attach to the virtual machine. If `devices` is not present,\nno change is made to devices. If either the device list order or data stored by the device changes when the\nattribute is passed, these actions are taken:\n\n1) If there is no device in the `devices` list which was previously attached to the VM, that device is\n   removed from the virtual machine.\n2) Devices are updated in the `devices` list when they contain a valid `id` attribute that corresponds to\n   an existing device.\n3) Devices that do not have an `id` attribute are created and attached to `id` VM.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vm_update_1"
              }
            }
          }
        }
      }
    },
    "/vm/id/{id}/clone": {
      "post": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Clone the VM `id`.\n\n`name` is an optional parameter for the cloned VM.\nIf not provided it will append the next number available to the VM name.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vm_clone_1"
              }
            }
          }
        }
      }
    },
    "/vm/flags": {
      "get": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns a dictionary with CPU flags for bhyve."
      }
    },
    "/vm/get_attached_iface": {
      "post": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get the attached physical interfaces from a given guest.\n\nReturns:\n    list: will return a list with all attached phisycal interfaces or otherwise False.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vm_get_attached_iface_0"
              }
            }
          }
        }
      }
    },
    "/vm/get_available_memory": {
      "post": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get the current maximum amount of available memory to be allocated for VMs.\n\nIf `overcommit` is true only the current used memory of running VMs will be accounted for.\nIf false all memory (including unused) of runnings VMs will be accounted for.\n\nThis will include memory shrinking ZFS ARC to the minimum.\n\nMemory is of course a very \"volatile\" resource, values may change abruptly between a\nsecond but I deem it good enough to give the user a clue about how much memory is\navailable at the current moment and if a VM should be allowed to be launched.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vm_get_available_memory_0"
              }
            }
          }
        }
      }
    },
    "/vm/get_console": {
      "post": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get the console device from a given guest.\n\nReturns:\n    str: with the device path or False.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vm_get_console_0"
              }
            }
          }
        }
      }
    },
    "/vm/get_instance": {
      "get": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/vm/get_vmemory_in_use": {
      "get": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "The total amount of virtual memory in MB used by guests\n\n    Returns a dict with the following information:\n        RNP - Running but not provisioned\n        PRD - Provisioned but not running\n        RPRD - Running and provisioned"
      }
    },
    "/vm/get_vnc": {
      "post": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get the vnc devices from a given guest.\n\nReturns:\n    list(dict): with all attributes of the vnc device or an empty list.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vm_get_vnc_0"
              }
            }
          }
        }
      }
    },
    "/vm/get_vnc_ipv4": {
      "get": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get all available IPv4 address in the system.\n\nReturns:\n   list: will return a list of available IPv4 address."
      }
    },
    "/vm/identify_hypervisor": {
      "get": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Identify Hypervisors that might work nested with bhyve.\n\nReturns:\n        bool: True if compatible otherwise False."
      }
    },
    "/vm/id/{id}/poweroff": {
      "post": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vm_poweroff"
              }
            }
          }
        }
      }
    },
    "/vm/random_mac": {
      "get": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a random mac address.\n\nReturns:\n    str: with six groups of two hexadecimal digits"
      }
    },
    "/vm/id/{id}/restart": {
      "post": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Restart a VM.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vm_restart"
              }
            }
          }
        }
      }
    },
    "/vm/id/{id}/start": {
      "post": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Start a VM.\n\noptions.overcommit defaults to false, meaning VMs are not allowed to\nstart if there is not enough available memory to hold all configured VMs.\nIf true, VM starts even if there is not enough memory for all configured VMs.\n\nError codes:\n\n    ENOMEM(12): not enough free memory to run the VM without overcommit",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vm_start_1"
              }
            }
          }
        }
      }
    },
    "/vm/id/{id}/status": {
      "post": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Get the status of a VM.\n\nReturns a dict:\n    - state, RUNNING or STOPPED\n    - pid, process id if RUNNING",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vm_status"
              }
            }
          }
        }
      }
    },
    "/vm/id/{id}/stop": {
      "post": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Stops a VM.\n\nFor unresponsive guests who have exceeded the `shutdown_timeout` defined by the user and have become\nunresponsive, they required to be powered down using `vm.poweroff`. `vm.stop` is only going to send a\nshutdown signal to the guest and wait the desired `shutdown_timeout` value before tearing down guest vmemory.\n\n`force_after_timeout` when supplied, it will initiate poweroff for the VM forcing it to exit if it has\nnot already stopped within the specified `shutdown_timeout`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vm_stop_1"
              }
            }
          }
        }
      }
    },
    "/vm/vnc_port_wizard": {
      "get": {
        "tags": [
          "vm"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "It returns the next available VNC PORT and WEB VNC PORT.\n\nReturns a dict with two keys vnc_port and vnc_web."
      }
    },
    "/vm/device": {
      "get": {
        "tags": [
          "vm.device"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "vm.device"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create a new device for the VM of id `vm`.\n\nIf `dtype` is the `RAW` type and a new raw file is to be created, `attributes.exists` will be passed as false.\nThis means the API handles creating the raw file and raises the appropriate exception if file creation fails.\n\nIf `dtype` is of `DISK` type and a new Zvol is to be created, `attributes.create_zvol` will be passed as\ntrue with valid `attributes.zvol_name` and `attributes.zvol_volsize` values.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vm_device_create_0"
              }
            }
          }
        }
      }
    },
    "/vm/device/id/{id}": {
      "delete": {
        "tags": [
          "vm.device"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete a VM device of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vm_device_delete_1"
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "vm.device"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "vm.device"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update a VM device of `id`.\n\nPass `attributes.size` to resize a `dtype` `RAW` device. The raw file will be resized.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vm_device_update_1"
              }
            }
          }
        }
      }
    },
    "/vm/device/get_instance": {
      "get": {
        "tags": [
          "vm.device"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/vm/device/nic_attach_choices": {
      "get": {
        "tags": [
          "vm.device"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Available choices for NIC Attach attribute."
      }
    },
    "/vm/device/pptdev_choices": {
      "get": {
        "tags": [
          "vm.device"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Available choices for PCI passthru device."
      }
    },
    "/vm/device/vnc_bind_choices": {
      "get": {
        "tags": [
          "vm.device"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Available choices for VNC Bind attribute."
      }
    },
    "/vmware": {
      "get": {
        "tags": [
          "vmware"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "post": {
        "tags": [
          "vmware"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Create VMWare snapshot.\n\n`hostname` is a valid IP address / hostname of a VMWare host. When clustering, this is the vCenter server for\nthe cluster.\n\n`username` and `password` are the credentials used to authorize access to the VMWare host.\n\n`datastore` is a valid datastore name which exists on the VMWare host.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vmware_create_0"
              }
            }
          }
        }
      }
    },
    "/vmware/id/{id}": {
      "delete": {
        "tags": [
          "vmware"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Delete VMWare snapshot of `id`."
      },
      "get": {
        "tags": [
          "vmware"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      },
      "put": {
        "tags": [
          "vmware"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Update VMWare snapshot of `id`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vmware_update_1"
              }
            }
          }
        }
      }
    },
    "/vmware/dataset_has_vms": {
      "post": {
        "tags": [
          "vmware"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns \"true\" if `dataset` is configured with a VMWare snapshot",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vmware_dataset_has_vms"
              }
            }
          }
        }
      }
    },
    "/vmware/get_datastores": {
      "post": {
        "tags": [
          "vmware"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Get datastores from VMWare.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vmware_get_datastores_0"
              }
            }
          }
        }
      }
    },
    "/vmware/get_instance": {
      "get": {
        "tags": [
          "vmware"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/vmware/get_virtual_machines": {
      "post": {
        "tags": [
          "vmware"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns Virtual Machines on the VMWare host identified by `pk`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vmware_get_virtual_machines_0"
              }
            }
          }
        }
      }
    },
    "/vmware/match_datastores_with_datasets": {
      "post": {
        "tags": [
          "vmware"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Requests datastores from vCenter server and tries to match them with local filesystems.\n\nReturns a list of datastores, a list of local filesystems and guessed relationship between them.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vmware_match_datastores_with_datasets_0"
              }
            }
          }
        }
      }
    },
    "/webdav": {
      "get": {
        "tags": [
          "webdav"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": []
      },
      "put": {
        "tags": [
          "webdav"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Update Webdav Service Configuration.\n\n`protocol` specifies which protocol should be used for connecting to Webdav Serivce. Value of \"HTTPHTTPS\"\nallows both HTTP and HTTPS connections to the share.\n\n`certssl` is a valid id of a certificate configured in the system. This is required if HTTPS connection is\ndesired with Webdave Service.\n\nThere are 3 types of Authentication supported with Webdav:\n1) NONE      -   No authentication is required\n2) BASIC     -   Password is sent over the network as plaintext\n3) DIGEST    -   Hash of the password is sent over the network\n\n`htauth` should be one of the valid types described above.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/webdav_update_0"
              }
            }
          }
        }
      }
    },
    "/webui/image": {
      "get": {
        "tags": [
          "webui.image"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ]
      }
    },
    "/webui/image/id/{id}": {
      "delete": {
        "tags": [
          "webui.image"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "id"
            }
          }
        ],
        "description": "Remove the database entry, and then the item if it exists"
      },
      "get": {
        "tags": [
          "webui.image"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ]
      }
    },
    "/webui/image/get_instance": {
      "get": {
        "tags": [
          "webui.image"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/zfs/snapshot": {
      "get": {
        "tags": [
          "zfs.snapshot"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "description": "Query all ZFS Snapshots with `query-filters` and `query-options`."
      },
      "post": {
        "tags": [
          "zfs.snapshot"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Take a snapshot from a given dataset.\n\nReturns:\n    bool: True if succeed otherwise False.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/zfs_snapshot_create_0"
              }
            }
          }
        }
      }
    },
    "/zfs/snapshot/id/{id}": {
      "delete": {
        "tags": [
          "zfs.snapshot"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "id",
              "type": "string"
            }
          }
        ],
        "description": "Delete snapshot of name `id`.\n\n`options.defer` will defer the deletion of snapshot.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/zfs_snapshot_delete_1"
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "zfs.snapshot"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "count",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "array",
              "title": "query-filters",
              "default": [],
              "items": {}
            }
          }
        ],
        "description": "Query all ZFS Snapshots with `query-filters` and `query-options`."
      }
    },
    "/zfs/snapshot/clone": {
      "post": {
        "tags": [
          "zfs.snapshot"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Clone a given snapshot to a new dataset.\n\nReturns:\n    bool: True if succeed otherwise False.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/zfs_snapshot_clone_0"
              }
            }
          }
        }
      }
    },
    "/zfs/snapshot/get_instance": {
      "get": {
        "tags": [
          "zfs.snapshot"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Returns instance matching `id`. If `id` is not found, Validation error is raised."
      }
    },
    "/zfs/snapshot/remove": {
      "post": {
        "tags": [
          "zfs.snapshot"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Remove a snapshot from a given dataset.\n\nReturns:\n    bool: True if succeed otherwise False.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/zfs_snapshot_remove_0"
              }
            }
          }
        }
      }
    },
    "/zfs/snapshot/rollback": {
      "post": {
        "tags": [
          "zfs.snapshot"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/Success"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          }
        },
        "parameters": [],
        "description": "Rollback to a given snapshot `id`.\n\n`options.recursive` will destroy any snapshots and bookmarks more recent than the one\nspecified.\n\n`options.recursive_clones` is just like `recursive` but will also destroy any clones.\n\n`options.force` will force unmount of any clones.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/zfs_snapshot_rollback"
              }
            }
          }
        }
      }
    }
  }
}